---
title: "Figures and Tables for 'Let's Talk About the Weather'"
author: "Jill Lundell"
date: "5/24/2021"
output: 
  html_document: default
  pdf_document: default
---

This R Markdown document contains the code to recreate the tables and folders in our "Let's talk about the weather" paper. Scripts with additional code are included in our github repository with a README that explains the flow to recreate and clean datasets, perform exploratory data analysis, and contain additional data and figures that were not presented in the paper or in the code below. 

The map data and other datasets needed to recreate the tables and figures from the table are included in an RData file. The map came from the R package "fiftystater" that was retired shortly after the Data Expo. The map has been included in the RData file for the ease of the reader. 

Some of the sizes of text and other objects in the plots have been resized so that they render properly in HTML. See the R scripts for each plot for the parameters used to create the PDF plots used in the paper. The name of the file that contains the original code is identified before each figure. All of the files can be found in the ./rscripts/final_analysis/ folder.

### Prepare environment

The first step is to load the RData file and the packages needed for this analysis. Note that each of the code chunks can be run separately as long as this one is run first. 

```{r setup, echo = TRUE, comment = FALSE, message = FALSE, warning = FALSE}

load("weather.RData")

library(cluster)
library(cowplot)
library(dplyr)
library(fpc)
library(GGally)
library(ggdendro)
library(ggmap)
library(ggplot2)
library(grid)
library(gridExtra)
library(gtable)
library(knitr)
library(latex2exp)
library(lubridate)
library(mapproj)
library(maps)
library(missForest)
library(randomForest)
library(RColorBrewer)
library(reshape2)
library(sp)
library(tidyr)
library(VIM)
library(xtable)

```

### Table 1: Weather variables and ranges

The following table shows the weather variables used in the analysis along with the units and ranges that were used to eliminate outliers. The  *weather*  datset was used to determine the final range of values, but the ranges are not the max and min values in the actual  *weather*  dataset. Thus, the table is not generated using the  *weather*  dataset. 


```{r table1, echo = TRUE, comment = FALSE, message = FALSE, warning = FALSE, results = "asis"}
col1 <- c("Min/Max Temperature", "Precipitation", "Min/Max Dew Point", 
          "Min/Max Humidity", "Min/Max Sea Level Pressure", 
          "Mean/Max Wind Speed", "Min Visibility ", "Cloud Cover", 
          "Distance to Coast", "Elevation")
col2 <- c("Fahrenheit", "Inches", "Fahrenheit", "Percent", "Inch of Mercury", 
          "Miles per Hour", "Miles", "Number of Eighths of the Sky Covered",
          "Miles", "Feet")
col3 <- c("circ F", "in", "circ F", "%", "inHg", "mph", "mi", "okta", 
          "mi", "ft")
col4 <- c("[-37, 127]", "[0, 12.95]", "[-50, 90]", "(0, 100]", "[28.2, 31.2]", 
          "[0, 70]", "[0, 10]", "{0, 1, ..., 8}", "[0, 807]", "[3, 7422]")

tab1 <- cbind(col1, col2, col3, col4)
colnames(tab1) <- c("Variable", "Unit", "Abbreviation", "Range")

print(kable(tab1), type = "html")

```

### Figure 1: Cluster map

The cluster map was created by first computing the clusters using hierarchical clustering with Euclidean distance and Ward's clustering criterion. See the file "finalMapScript.R" for the exact code used to generate the PDF graphs used in the paper.  

```{r clusterMap, echo = TRUE, comment = FALSE, message = FALSE, warning = FALSE}
# Copy city dataset for further manipulation
cluster2 <- city

# Impute Baltimore values with nearest neighbor (Dover, DE). 
cluster2$Min_Vis[cluster2$AirPtCd == "KDMH"] <- 
  cluster2$Min_Vis[cluster2$AirPtCd == "KDOV"]
cluster2$Sd_Vis[cluster2$AirPtCd == "KDMH"] <- 
  cluster2$Sd_Vis[cluster2$AirPtCd == "KDOV"]
cluster2$CloudCover[cluster2$AirPtCd == "KDMH"] <- 
  cluster2$CloudCover[cluster2$AirPtCd == "KDOV"]
cluster2$Sd_CloudCover[cluster2$AirPtCd == "KDMH"] <- 
  cluster2$Sd_CloudCover[cluster2$AirPtCd == "KDOV"]

# Impute Austin, NV values with nearest neighbor (Reno)
cluster2$CloudCover[cluster2$AirPtCd == "KP68"] <- 
  cluster2$CloudCover[cluster2$AirPtCd == "KRNO"]
cluster2$Sd_CloudCover[cluster2$AirPtCd == "KP68"] <- 
  cluster2$Sd_CloudCover[cluster2$AirPtCd == "KRNO"]
cluster2$Min_Vis[cluster2$AirPtCd == "KP68"] <- 
  cluster2$Min_Vis[cluster2$AirPtCd == "KRNO"]
cluster2$Sd_Vis[cluster2$AirPtCd == "KP68"] <- 
  cluster2$Sd_Vis[cluster2$AirPtCd == "KRNO"]

cc2 <- cluster2 %>% dplyr::select(-AirPtCd, -city, -state, -longitude, 
                                  -latitude, -mxT_sd, -mxT_mean, -mnT_sd, 
                                  -mnT_mean, -mxT_sd_abs, -mxT_mean_abs, 
                                  -mnT_sd_abs, -mnT_mean_abs, -BSS)

cc2 <- scale(cc2)

d2 <- dist(cc2, method = "euclidean")
c2 <- hclust(d2, method = "ward.D2")
l2 <- cutree(c2, k = 6)

cluster2$Cluster <- l2

tmp <- as.data.frame(cluster2)
tmp$state <- as.character(tmp$state)
# Help for abbreviations from:
# - https://stackoverflow.com/questions/5411979/state-name-to-abbreviation-in-r
tmp$stateABB <- "none"
for (i in 1:nrow(tmp)) {tmp$stateABB[i] <- state.abb[grep(tmp$state[i], 
                                                        state.name)]}
cluster2$stateABB <- tmp$stateABB
tmp$state <- tolower(tmp$state)
longitude <- c(-117.25, -108.50)
latitude <- c(27.2, 27)

pal1 <- brewer.pal(6, "Dark2")
pal2 <- brewer.pal(8, "Set1")[c(1:5, 8)]
pal2 <- pal2[c(4, 2, 3, 6, 1, 5)]
pal3 <- brewer.pal(7, "Set3")[-2]

# Create copy of tmp file where we adjust the coordinates for alaska and hawaii
tmp2 <- tmp
tmp2$latitude[tmp2$state == "alaska"] <- latitude[1]
tmp2$latitude[tmp2$state == "hawaii"] <- latitude[2]
tmp2$longitude[tmp2$state == "alaska"] <- longitude[1]
tmp2$longitude[tmp2$state == "hawaii"] <- longitude[2]

noi <- c("Austin, NV", "Duluth, MN", "Watertown, NY", "Fresno, CA", 
         "Key West, FL")
tmp2$name <- paste(tmp2$city, tmp2$stateABB, sep = ", ")
tmp2.sub <- tmp2[is.element(tmp2$name, noi), ]

p2 <- ggplot(tmp2, aes(map_id = state)) +
  # map points to the fifty_states shape data
  geom_map(fill = alpha("gray80", 0.5), color = alpha("gray60", 0.5), 
           map = fifty_states) +
  expand_limits(x = fifty_states$long, y = fifty_states$lat) +
  coord_map() +
  scale_x_continuous(breaks = NULL) +
  scale_y_continuous(breaks = NULL) +
  labs(x = "", y = "") +
  theme(legend.position = "bottom",
        panel.background = element_blank()) +
  geom_point(data = tmp2, aes(x = longitude, y = latitude),
             fill = alpha(pal2[tmp2$Cluster], 0.8), size = 3, shape = I(21))

# Add the legend.
#=============================================================================
# First, create a set of boxes that we can color differently. 
tbox.x <- c(0, 0, 5, 5, 0)
tbox.y <- c(0, 1, 1, 0, 0)

# Now create a series of 6 boxes. 
boxes <- data.frame(x = c(tbox.x, tbox.x + 5, tbox.x + 10, tbox.x + 15, 
                          tbox.x + 20, tbox.x + 25),
                    y = rep(tbox.y, 6),
                    group = c(rep(1, 5), rep(2, 5), rep(3, 5), 
                              rep(4, 5), rep(5, 5), rep(6, 5)))

legend <- ggplot(boxes, aes(x = x, y = y)) + 
  geom_polygon(aes(fill = factor(group)), color = "white") + 
  coord_fixed() +
  scale_color_manual(values = c("#f781bf", "#4daf4a", "#377eb8",  
                                "#e41a1c", "#984ea3", "#ff7f00")) + 
  scale_fill_manual(values = c("#f781bf", "#4daf4a", "#377eb8", 
                               "#e41a1c", "#984ea3",  "#ff7f00")) + 
  annotate("text", x = 2.5 + c(0, 5, 10, 15, 20, 25), 
           y = rep(0.5, 6), 
           label = c("Cali-Florida", "Southeast", "Northeast", 
                     "Intermountain West", "Midwest", "Southwest"), 
           color = "white", size = c(3, 3, 3, 2.5, 3, 3)) + 
  theme(legend.position = "none",
        panel.background = element_blank(),
        axis.line = element_blank(),
        axis.text = element_blank(),
        axis.title = element_blank(),
        axis.ticks = element_blank())
#=============================================================================

grid.arrange(grobs = list(ggplotGrob(p2), ggplotGrob(legend)), 
             heights = c(2, 0.2))


```

### Figure 2: Dendrogram

The following is a dendrogram of the clusters shown in Figure 1. The original code for the plot that was rendered in the paper is in the file "finalDendro.pdf". 

```{r dendro, echo = TRUE, comment = FALSE, message = FALSE, warning = FALSE, fig.height = 12}

# Copy city dataset for further manipulation
cluster2 <- city
cluster2$state <- as.character(cluster2$state)
# Help for abbreviations from:
# - https://stackoverflow.com/questions/5411979/state-name-to-abbreviation-in-r
cluster2$stateABB <- "none"
for (i in 1:nrow(cluster2)) {
  cluster2$stateABB[i] <- state.abb[grep(cluster2$state[i], state.name)]
}
cluster2$name <- paste(cluster2$city, cluster2$stateABB, sep = ", ")

# Impute Baltimore values with nearest neighbor (Dover, DE). 
cluster2$Min_Vis[cluster2$AirPtCd == "KDMH"] <- 
  cluster2$Min_Vis[cluster2$AirPtCd == "KDOV"]
cluster2$Sd_Vis[cluster2$AirPtCd == "KDMH"] <- 
  cluster2$Sd_Vis[cluster2$AirPtCd == "KDOV"]
cluster2$CloudCover[cluster2$AirPtCd == "KDMH"] <- 
  cluster2$CloudCover[cluster2$AirPtCd == "KDOV"]
cluster2$Sd_CloudCover[cluster2$AirPtCd == "KDMH"] <- 
  cluster2$Sd_CloudCover[cluster2$AirPtCd == "KDOV"]

# Impute Austin, NV values with nearest neighbor (Reno)
cluster2$CloudCover[cluster2$AirPtCd == "KP68"] <- 
  cluster2$CloudCover[cluster2$AirPtCd == "KRNO"]
cluster2$Sd_CloudCover[cluster2$AirPtCd == "KP68"] <- 
  cluster2$Sd_CloudCover[cluster2$AirPtCd == "KRNO"]
cluster2$Min_Vis[cluster2$AirPtCd == "KP68"] <- 
  cluster2$Min_Vis[cluster2$AirPtCd == "KRNO"]
cluster2$Sd_Vis[cluster2$AirPtCd == "KP68"] <- 
  cluster2$Sd_Vis[cluster2$AirPtCd == "KRNO"]

cc2 <- cluster2 %>% dplyr::select(-AirPtCd, -city, -state, -stateABB, -name, 
                                  -longitude, -latitude, -mxT_sd, -mxT_mean, 
                                  -mnT_sd, -mnT_mean, -mxT_sd_abs, 
                                  -mxT_mean_abs, -mnT_sd_abs, -mnT_mean_abs,
                                  -BSS)

cc2 <- scale(cc2)

d2 <- dist(cc2, method = "euclidean")
c2 <- hclust(d2, method = "ward.D2")
l2 <- cutree(c2, k = 6)

# cluster2$Cluster <- l2

# Define color scheme
set1 <- c("#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", "#f781bf", 
          "gray50")
set1 <- set1[c(4, 2, 3, 6, 1, 5, 7)] # Reorder to match the original layout


# Code adapted from answer given  by "jlhoward" at:
# https://stackoverflow.com/questions/21474388/colorize-clusters-in-dendogram-with-ggplot2
#==============================================================================
dendr <- dendro_data(c2, type = "rectangle") # convert for ggplot
dendr[["labels"]]$label <- 
  cluster2$name[as.numeric(as.character(dendr[["labels"]]$label))]
clust.df <- data.frame(label = cluster2$name, cluster = factor(l2))
# dendr[["labels"]] has the labels, merge with clust.df based on label column
dendr[["labels"]] <- merge(dendr[["labels"]], clust.df, by = "label")
# plot the dendrogram; note use of color=cluster in geom_text(...)
p1 <- ggplot() + 
  geom_segment(data = segment(dendr), aes(x = x, y = y, xend = xend, 
                                          yend = yend)) + 
  geom_text(data = dendr$labels, aes(x, y, label = label, hjust = 0, 
                                     color = cluster), size = 2.5) +
  coord_flip() + 
  scale_y_reverse(expand = c(0, 0), limits = c(40, -15)) + 
  scale_color_manual(values = set1) + 
  theme(legend.position = "none",
    axis.line = element_blank(),
        axis.ticks = element_blank(),
        axis.text = element_blank(),
        axis.title = element_blank(),
        panel.background = element_rect(fill = "white"),
        panel.grid = element_blank())
#=============================================================================

p1

```


### Figure 3: Parallel coordinate plot of weather variables at each station

The parallel coordinate plot has a line for each of the weather stations that shows the indicated summary statistic for each of the clustering variables. The lines are colored according to the cluster that they belong to. Stations in the Southwest cluster are emphasized. The original code for the plot that was rendered in the paper is in the file "final_PCP.pdf". 

```{r pcp, echo = TRUE, comment = FALSE, message = FALSE, warning = FALSE, fig.height = 4, fig.width = 9}

# Copy map dataset for further manipulation
cluster2 <- map

cluster2$name <- paste(cluster2$city, cluster2$stateABB, sep = ", ")

clusterSum <- cluster2 %>% 
  group_by(Cluster) %>% 
  summarize(maxabsG = mean(mxT_mean_abs))
cluster2 <- left_join(cluster2, clusterSum, by = "Cluster") %>% 
  arrange(maxabsG, mxT_mean_abs)
cluster2$maxabsG <- NULL

cluster2$AirPtCd <- factor(cluster2$AirPtCd, levels = cluster2$AirPtCd)
cluster2$Cluster <- factor(cluster2$Cluster, levels = unique(cluster2$Cluster))

cluster2 <- cluster2 %>% 
  dplyr::select(-mxT_sd, -mnT_sd, -mxT_sd_abs, -mnT_sd_abs,
                -mxT_mean, -mnT_mean, -mxT_mean_abs, -mnT_mean_abs,
                -BSS)

pal2 <- brewer.pal(8, "Set1")[c(1:5, 8)]
pal2 <- pal2[rev(c(1, 4, 2, 3, 6, 5))]

# Designate "names of interest"
noi <- c("Austin, NV", "Duluth, MN", "Watertown, NY", "Fresno, CA", 
         "Key West, FL")
arpts <- cluster2$AirPtCd[is.element(cluster2$name, noi)]

cluster2.sd <- cluster2 %>% 
  dplyr::select(contains("Sd"), elevation, dist2coast, Cluster, AirPtCd)
cluster2.sd[, 1:15] <- scale(cluster2.sd[, 1:15])

cluster2.other <- cluster2 %>% 
  dplyr::select(-contains("Sd"), -city, -state, -longitude, 
                -latitude, -stateABB, -name)
cluster2.other[, 2:16] <- scale(cluster2.other[, 2:16])

cluster2.sd.long <- melt(cluster2.sd, id.vars = c("Cluster", "AirPtCd"))
cluster2.sd.long$value[is.element(cluster2.sd.long$variable, 
                                  c("elevation", "dist2coast"))] <- 0
cluster2.other.long <- melt(cluster2.other, id.vars = c("Cluster", "AirPtCd"))

# Emphasize cluster
cluster2.sd.long.sub <- 
  cluster2.sd.long[is.element(as.character(cluster2.sd.long$Cluster), "6"), ]
cluster2.other.long.sub <- 
  cluster2.other.long[is.element(as.character(cluster2.other.long$Cluster), 
                                 "6"), ]

# Manually jitter values to fit. 
suby <- 
  cluster2.sd.long.sub$value[cluster2.sd.long.sub$variable == "Sd_Max_Temp"]
suby[3] <- suby[3] + 0.2
suby[5] <- suby[5] - 0.2

cluster2.sd.long$title1 <- "Measurement Standard Deviations"

p1 <- ggplot(cluster2.sd.long, aes(x = variable, y = value, 
                                   group = factor(AirPtCd))) + 
  geom_path(aes(color = factor(Cluster)), alpha = 0.4) +
  scale_color_manual(values = pal2) + 
  ylim(-5.05, 5) +
  ylab( "Z") +
  geom_path(data = cluster2.sd.long.sub,
            aes(x = variable, y = value, group = factor(AirPtCd), 
                color = factor(Cluster)), lwd = 1.5, alpha = 0.6) +
  facet_grid(~title1) + 
  theme_bw() +
  scale_x_discrete(labels = c("Max Temp", "Min Temp", "Precip", "Max DP", 
                              "Min DP", "Max Hum", "Min Hum", "Max SLP", 
                              "Min SLP", "Vis", "Clouds", "Mean WS", 
                              "Max WS", "Elevation", "Dist2Coast")) + 
  theme(legend.position = "none",
        axis.text.y = element_text(size = 10),
        axis.text.x = element_text(angle = 20, hjust = 1, vjust = 1, 
                                   size = 10),
        axis.title.x = element_blank(), 
        axis.title.y = element_text(size = 10),
        strip.text.x = element_text(size = 14))

# Expand idea from scale_x_discrete help file. 
cluster2.other.long$title1 <- "Measurement Means"
p2 <- ggplot(cluster2.other.long, aes(x = variable, y = value, 
                                      group = factor(AirPtCd))) + 
  geom_path(aes(color = factor(Cluster)), alpha = 0.3) +
  scale_color_manual(values = pal2) + 
  ylim(-5.05, 5) +
  ylab( "Z") +
  geom_path(data = cluster2.other.long.sub,
            aes(x = variable, y = value, group = factor(AirPtCd), 
                color = factor(Cluster)), lwd = 1.5, alpha = 0.6) + 
  facet_grid(~title1) + 
  theme_bw() +
  theme(legend.position = "none",
        axis.text.y = element_text(size = 10),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.title.x = element_blank(), 
        axis.title.y = element_text(size = 10),
        strip.text.x = element_text(size = 14))

#=============================================================================
# First, create a set of boxes that we can color differently. 
tbox.x <- c(0, 0, 5, 5, 0)
tbox.y <- c(0, 6, 6, 0, 0)

# Now create a series of 6 boxes. 
boxes <- data.frame(x = c(tbox.x, tbox.x + 5, tbox.x + 10, tbox.x + 15, 
                          tbox.x + 20, tbox.x + 25),
                    y = rep(tbox.y, 6),
                    group = c(rep(1, 5), rep(2, 5), rep(3, 5), 
                              rep(4, 5), rep(5, 5), rep(6, 5)))

legend <- ggplot(boxes, aes(x = x, y = y)) + 
  geom_polygon(aes(fill = factor(group)), color = "white") + 
  coord_fixed() +
  scale_color_manual(values = c("#f781bf", "#4daf4a", "#377eb8",  
                                "#e41a1c", "#984ea3", "#ff7f00")) + 
  scale_fill_manual(values = c("#f781bf", "#4daf4a", "#377eb8", 
                               "#e41a1c", "#984ea3",  "#ff7f00")) + 
  annotate("text", x = 2.5 + c(0, 5, 10, 15, 20, 25), 
           y = rep(3, 6), 
           label = c("Cali-Florida", "Southeast", "Northeast", 
                     "Intermountain West", "Midwest", "Southwest"), 
           color = "white", size = c(3, 3, 3, 2.5, 3, 3)) + 
  theme(legend.position = "none",
        panel.background = element_blank(),
        axis.line = element_blank(),
        axis.text = element_blank(),
        axis.title = element_blank(),
        axis.ticks = element_blank())
#=============================================================================

grid.draw(rbind(rbind(ggplotGrob(p2), ggplotGrob(p1), size = "last"), 
                ggplotGrob(legend), size = "first"))

```


### Figure 4: Correlation glyph plot

The correlation glyph plot shows the correlation between the weather prediction variables in each of the weather clusters. This plot creates glyphs and then places them on the map. Not only is this code a good resource for making glyphs, but it also demonstrates how to work around the difference between coordinate systems for the map and the glyphs so that the glyphs are not distorted. Original code for creating the pdf image used in the paper see the file "finalCorBarChart2.pdf". 

```{r corr, echo = TRUE, comment = FALSE, message = FALSE, warning = FALSE, fig.width = 10}

# Copy fifty_states dataset for further manipulation. This code alters the 
# map data. The location and city datasets are also copied to preserve
# the datasets for future analysis. 

states <- fifty_states 
loc2 <- locations
city2 <- city

# Adjust the final plot margins as needed.
marAdj <- c(0, 0, 0, 0)
plot.margin <- unit(marAdj, "cm")

loc2$state <- tolower(loc2$state)

# Calculate inverse of Brier Skill score as we want larger numbers
# to indicate more error. 
city2$iBSS <- 1 - city2$BSS 

corMethod <- "spearman"

# Change coordinates of Alaska and Hawaii to match the map we use.
longitude <- c(-117.25, -108.50)
latitude <- c(27.2, 27)
loc2$latitude[loc2$state == "alaska"] <- latitude[1]
loc2$latitude[loc2$state == "hawaii"] <- latitude[2]
loc2$longitude[loc2$state == "alaska"] <- longitude[1]
loc2$longitude[loc2$state == "hawaii"] <- longitude[2]

city2$latitude[city2$state == "Alaska"] <- latitude[1]
city2$latitude[city2$state == "Hawaii"] <- latitude[2]
city2$longitude[city2$state == "Alaska"] <- longitude[1]
city2$longitude[city2$state == "Hawaii"] <- longitude[2]

# Make a temporary data frame of coordinates so that everyting gets 
# identically projected:
coordDF <- data.frame(long = c(states$long, city2$longitude),
                      lat = c(states$lat, city2$latitude),
                      id = c(rep(1, nrow(states)), rep(2, nrow(city2))))

tcoords <- mapproject(coordDF$long, coordDF$lat, projection = "mercator",
                      parameters = NULL, orientation=NULL)

states$long <- tcoords$x[coordDF$id == 1]
states$lat <- tcoords$y[coordDF$id == 1]

city2$longitude2 <- tcoords$x[coordDF$id == 2]
city2$latitude2 <- tcoords$y[coordDF$id == 2]

locs.sub <- loc2 %>% dplyr::select(AirPtCd, Cluster6, color)

city2 <- left_join(city2, locs.sub, by = "AirPtCd")

city3 <- city2
city3$Cluster6 <- 7
city3 <- bind_rows(city2, city3)

# Calculate non-parametric cluster specific correlations.
latLonSum <- city3 %>% group_by(Cluster6) %>%
  summarize(long = mean(longitude2),
            lat = mean(latitude2)
  )

# Adjust individual lat/long coordinates as needed
# (particularly for those thrown off by Alaska and Hawaii)
# longitude adjustment
lonAdj <- c(0, 0.15, 0, -0.2, 0, 0, 0.45)
latAdj <- c(0, 0.05, 0, 0.05, 0.05, 0, -0.21)

latLonSum$long <- latLonSum$long + lonAdj
latLonSum$lat <- latLonSum$lat + latAdj


# Generate the coordinates for the ellipses for each correlation 
# and each cluster. Store as one common data frame.  
tempEllipse <- vector("list", 7)
tempEllipse.sub <- vector("list", 3)

grd <- 0.55
adj.lon <- grd * c(-1, 1, 1)
adj.lat <- grd * c(1, 1, -1)

# Change the size of the plots
arrayAdj <- 0.07 
# arrayAdj <- 0.035

# Combine the correlation information into a common data frame. 
# This data frame includes the equations for the ellipses. 
for (i in 1:length(tempEllipse)) {
  temp <- cor(city3[city3$Cluster6 == i, c("mxT_mean_abs", "mnT_mean_abs", 
                                                       "iBSS")],
              method = corMethod)
  temp.p1 <- cor.test(city3[city3$Cluster6 == i, "mxT_mean_abs"],
                      city3[city3$Cluster6 == i, "mnT_mean_abs"],
                      method = corMethod)
  temp.p2 <- cor.test(city3[city3$Cluster6 == i, "mxT_mean_abs"],
                      city3[city3$Cluster6 == i, "iBSS"],
                      method = corMethod)
  temp.p3 <- cor.test(city3[city3$Cluster6 == i, "mnT_mean_abs"],
                      city3[city3$Cluster6 == i, "iBSS"],
                      method = corMethod)
  temp.p <- c(temp.p1$p.value, temp.p2$p.value, temp.p3$p.value)
  temp <- temp[c(2, 3, 6)]
  # If a correlation is exactly equal to 0, adjust to avoid numerical 
  # difficulties.
  temp[temp == 0] <- 0.001
  # Adjust the number of plot points depending on how narrow the ellipse is. 
  # The more narrow the ellipse, the more points we need to characterize the 
  # turns. 
  pointAdj <- c(0.0025, 0.025, 0.05, 0.025)
  for (j in 1:length(tempEllipse.sub)) {
    # Change the number of points based on the shape of the ellipse. 
    if (sign(temp[j]) < 0) {
      tPointAdj <- pointAdj[c(2, 3, 4, 1)]
    } else {
      tPointAdj <- pointAdj
    }
    tempEllipse.sub[[j]] <- 
      data.frame(dRad = c(seq(0, 0.5, tPointAdj[1] * (1 - abs(temp[j]))) * pi, 
                          seq(0.5, 1, tPointAdj[2] * (1 - abs(temp[j]))) * pi,
                          seq(1, 1.5, tPointAdj[3] * (1 - abs(temp[j]))) * pi,
                          seq(1.5, 2, tPointAdj[4] * (1 - abs(temp[j]))) * pi),
                 Cluster = i,
                 CorType = j,
                 long = latLonSum$long[i] + arrayAdj * adj.lon[j],
                 lat = latLonSum$lat[i] + arrayAdj * adj.lat[j],
                 cor = temp[j],
                 pval = temp.p[j])
  }
  
  tempEllipse[[i]] <- bind_rows(tempEllipse.sub)
}

# Convert the polar coordinates of the ellipse to cartesian. 
# - http://math.etsu.edu/multicalc/prealpha/chap3/chap3-2/part4.htm
tempEllipse <- bind_rows(tempEllipse)
tempEllipse <- tempEllipse %>%
  mutate(c = sqrt(abs(cor) * (2-abs(cor))),
         r = (1 - abs(cor))^2 / (1 - c * cos(dRad - sign(cor) * pi / 4)),
         x = r * cos(dRad) - sqrt(c^2 / 2),
         y =  r * sin(dRad) - sign(cor) * sqrt(c^2 / 2))

adj <- tempEllipse %>% group_by(Cluster, CorType) %>% 
  summarize(adj = max(abs(x)) / 0.5)

tempEllipse <- left_join(tempEllipse, adj)

tempEllipse$group <- paste(tempEllipse$Cluster, tempEllipse$CorType, sep = ".")

# Determine the non-significant correlations. 
pvalSum <- tempEllipse %>% 
  group_by(Cluster, CorType) %>% 
  dplyr::select(Cluster, CorType, long, lat, pval) %>%
  slice(1) %>%
  filter(pval >= 0.05)

# Define color scheme
set1 <- c("#e41a1c", "#377eb8", "#4daf4a", "#984ea3", 
          "#ff7f00", "#f781bf", "gray50")
set1 <- set1[c(4, 2, 3, 6, 1, 5, 7)] # Reorder to match the original layout

# CREATE LEGEND
#=============================================================================
# Change the size of the plots
legendAdj <- 0.03

# Generate the coordinates for the ellipses for each correlation 
# and each cluster. Store as one common data frame.  
tempCor <- seq(-1, 1, 0.25)
# Slight adjustment to 0 to make plots consistent. 
tempCor[tempCor == 0] <- 0.0000001
tempLegend <- vector("list", length(tempCor))
for (j in 1:length(tempCor)) {
  
  # Change the number of plotted points based on the type of ellipse. 
  if (tempCor[j] == 1) {
    tdRad <- c(pi / 4, 5 * pi / 4)
    # Adjust the value of b to avoid missing values. 
    lineAdj <- 0.0000001
  } else if (tempCor[j] == -1) {
    tdRad <- c(3 * pi / 4, 7 * pi / 4)
    # Adjust the value of b to avoid missing values. 
    lineAdj <- -0.0000001
  } else {
    if (sign(tempCor[j]) < 0) {
      tPointAdj <- pointAdj[c(2, 3, 4, 1)]
    } else {
      tPointAdj <- pointAdj
    }
    tdRad <- c(seq(0, 0.5, tPointAdj[1] * (1 - abs(tempCor[j]))) * pi, 
               seq(0.5, 1, tPointAdj[2] * (1 - abs(tempCor[j]))) * pi,
               seq(1, 1.5, tPointAdj[3] * (1 - abs(tempCor[j]))) * pi,
               seq(1.5, 2, tPointAdj[4] * (1 - abs(tempCor[j]))) * pi)
    # Adjust the value of b to avoid missing values. 
    lineAdj <- 0
  }
  
  tempLegend[[j]] <- data.frame(dRad = tdRad,
                                long = (j - 1) * legendAdj,
                                b = (1 - abs(tempCor[j])) * sign(tempCor[j]) + 
                                  lineAdj, # Adjustment avoids radii of 0.
                                id = j)
  
}

tempLegend <- bind_rows(tempLegend)
tempLegend$r[is.nan(tempLegend$r) || tempLegend$r == 0] <- 0.5

tempLegend <- tempLegend %>%
  mutate(c = sqrt(1 - b^2),
         r = b^2 / (1 - c * cos(dRad - sign(b) * pi / 4)),
         x = r * cos(dRad) - sqrt(c^2 / 2),
         y =  r * sin(dRad) - sign(b) * sqrt(c^2 / 2))

# Note that max(x) and max(y) are identical by construction. No need to 
# define both. 
adj <- tempLegend %>% group_by(id) %>% summarize(adj = max(abs(x)) / 0.5)

tempLegend <- left_join(tempLegend, adj)
#=============================================================================


# Create the plot
#=============================================================================
loc2$Title <- "Error Correlations by Cluster"
mapEllipse <- ggplot(tempEllipse) + 
  geom_map(data = loc2, aes(map_id = state),
           fill = alpha("gray80", 0.5), color = alpha("gray60", 0.5),
           map = states) +
  expand_limits(x = states$long, y = states$lat) +
  geom_polygon(aes(x = arrayAdj * x / adj + long, y = arrayAdj * y / adj + lat, 
                   group = group, fill = factor(Cluster))) +
  # Add the reference grid lines.
  annotate("segment", 
           x = c(latLonSum$long - 2 * arrayAdj * grd,
                 latLonSum$long - 2 * arrayAdj * grd,
                 latLonSum$long, 
                 latLonSum$long,
                 latLonSum$long + 2 * arrayAdj * grd,
                 latLonSum$long - 2 * arrayAdj * grd), 
           y = c(latLonSum$lat, 
                 latLonSum$lat + 2 * arrayAdj * grd,
                 latLonSum$lat - 2 * arrayAdj * grd,
                 latLonSum$lat - 2 * arrayAdj * grd,
                 latLonSum$lat - 2 * arrayAdj * grd,
                 latLonSum$lat),
           xend = c(latLonSum$long + 2 * arrayAdj * grd,
                    latLonSum$long + 2 * arrayAdj * grd,
                    latLonSum$long + 2 * arrayAdj * grd,
                    latLonSum$long,
                    latLonSum$long + 2 * arrayAdj * grd,
                    latLonSum$long - 2 * arrayAdj * grd), 
           yend = c(latLonSum$lat,
                    latLonSum$lat + 2 * arrayAdj * grd,
                    latLonSum$lat - 2 * arrayAdj * grd,
                    latLonSum$lat + 2 * arrayAdj * grd,
                    latLonSum$lat + 2 * arrayAdj * grd,
                    latLonSum$lat + 2 * arrayAdj * grd),
           col = alpha("black", 1), lwd = 0.7) + 
  # Add the variable labels
  annotate("text", 
           x = latLonSum$long[7] + c(-3.75, -1.75, -1.75, 1) * grd * arrayAdj, 
           y = latLonSum$lat[7] + c(1, 2.4, -1, 2.4) * grd * arrayAdj,
           label = c("Max Temp", "Min Temp", "Min Temp", "Precip"),
           size = 3) + 
  # Add the "combined" title
  annotate("text", x = latLonSum$long[7], 
           y = latLonSum$lat[7] + 3.5 * grd * arrayAdj,
           label = c("Combined"), size = 5) + 
  # Add the significance annotation. 
  annotate("point", x = 0.09, y = 0.98, pch = 4, size = 1, stroke = 2) +
  annotate("text", x = 0.1, y = 0.98, 
           label = TeX("Non-significant correlation ($\\alpha = 0.05$)", 
                       output = 'character'), 
           hjust = -0.05, 
           parse = TRUE, size = 3) +
  # Add "x" to all correlations that are not significant. 
  # Stroke option help:
  # - https://ggplot2.tidyverse.org/reference/geom_point.html
  annotate("point", x = pvalSum$long, pvalSum$lat, pch = 4, size = 1, 
           stroke = 2, color = alpha("black", 0.5)) + 
  # Add the legend:
  geom_polygon(data = tempLegend, 
               aes(x = legendAdj * x / adj + long + (id - 1) * 
                     (grd - 0.53) - 0.1, 
                   y = legendAdj * y / adj + 0.4, group = factor(id)),
               inherit.aes = FALSE,
               fill = "black", color ="black", lwd = 1) + 
  annotate("text", 
           x = unique(tempLegend$long)[c(1, 3, 5, 7, 9)] + 
             seq(0, 8, 2) * (grd - 0.53) - 0.1, y = -0.06 + 0.4, 
           label = c("-1", "-0.5",  "0", "0.5", "1"), 
           size = 3) + 
  annotate("text", 
           x = unique(tempLegend$long)[5] + 
             4 * (grd - 0.53) - 0.1, y = 0.05 + 0.4, 
           label = "Correlation", size = 5) + 
  annotate("point", 
           x = unique(tempLegend$long) + 
             0:8 * (grd - 0.53) - 0.1, y = -0.03 + 0.4, 
           pch = "|", size = 6) + 
  annotate("segment", 
           x = unique(tempLegend$long) +
             0 * (grd - 0.53) - 0.1, y = -0.03 + 0.4, 
           xend = unique(tempLegend$long) + 
             8 * (grd - 0.53) - 0.1, yend = -0.03 + 0.4) + 
  coord_fixed() + # Ensures integrity of shapes. 
  scale_fill_manual(values = alpha(set1, 0.5)) + 
  theme(panel.background = element_blank(),
        panel.border = element_blank(),
        panel.grid = element_blank(),
        axis.title = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        legend.position = "none",
        plot.margin = unit(marAdj, "cm")) 

#=============================================================================
# First, create a set of boxes that we can color differently. 
tbox.x <- c(0, 0, 5, 5, 0)
tbox.y <- c(0, 1, 1, 0, 0)

# Now create a series of 6 boxes. 
boxes <- data.frame(x = c(tbox.x, tbox.x + 5, tbox.x + 10, tbox.x + 15, 
                          tbox.x + 20, tbox.x + 25),
                    y = rep(tbox.y, 6),
                    group = c(rep(1, 5), rep(2, 5), rep(3, 5), 
                              rep(4, 5), rep(5, 5), rep(6, 5)))

legend <- ggplot(boxes, aes(x = x, y = y)) + 
  geom_polygon(aes(fill = factor(group)), color = "white") + 
  coord_fixed() +
  scale_color_manual(values = c("#f781bf", "#4daf4a", "#377eb8",  
                                "#e41a1c", "#984ea3", "#ff7f00")) + 
  scale_fill_manual(values = c("#f781bf", "#4daf4a", "#377eb8", 
                               "#e41a1c", "#984ea3",  "#ff7f00")) + 
  annotate("text", x = 2.5 + c(0, 5, 10, 15, 20, 25), 
           y = rep(0.5, 6), 
           label = c("Cali-Florida", "Southeast", "Northeast", 
                     "Intermountain West", "Midwest", "Southwest"), 
           color = "white", size = c(4, 4, 4, 3, 4, 4)) + 
  theme(legend.position = "none",
        panel.background = element_blank(),
        axis.line = element_blank(),
        axis.text = element_blank(),
        axis.title = element_blank(),
        axis.ticks = element_blank())
#=============================================================================

grid.arrange(grobs = list(ggplotGrob(mapEllipse), ggplotGrob(legend)),
                        heights = c(0.9, 0.1))


```


### Figure 5: Scatterplots linked with map

These scatterplots are examples of graphs generated by our shiny app. The app allows the user to select points on the scatterplot and see where they are located on the map. Original code for creating the pdf image used in the paper see the file "final_Scatterplot_Lag.pdf". 

```{r scatter, comment = FALSE, message = FALSE, warning = FALSE, results = "hide"}

# Control the sizes of the labels and titles
size1 <- 16 # Numbers
size2 <- 18 # Titles
size3 <- 20 # Plot Title

# We changed data files to one that had all of the lags. lag = 10 is the data 
# aggregated over all of the lags.
scatter <- forecast
scatter$BSS <- 1 - scatter$BSS

clust <- locations
clust <- clust[, c(6, 18:21)]

scatter <- left_join(scatter, clust)
scatter$state <- tolower(scatter$state)

longitude <- c(-117.25, -108.50)
latitude <- c(27.2, 27)
scatter$latitude[scatter$state == "alaska"] <- latitude[1]
scatter$latitude[scatter$state == "hawaii"] <- latitude[2]
scatter$longitude[scatter$state == "alaska"] <- longitude[1]
scatter$longitude[scatter$state == "hawaii"] <- longitude[2]


#===========================================================================
# Scatterplots for data outliers
#===========================================================================

# Initial plot aggregated over lags
agg <- scatter[scatter$lag == 10, ]

# Bad on min/max
s1 <- agg[agg$mnT_mean_abs > 5 | agg$mnT_mean_abs < 3, ]

# precip extremes
s2 <- agg[agg$BSS > 1.43, ]

# good with min/max
s3 <- agg[(agg$mxT_mean_abs < 1.5 | agg$mxT_mean_abs > 6 | 
             (agg$mnT_mean_abs < 2.5 & agg$mxT_mean_abs > 4.5)), ]

# figure for slides
s4 <- agg[agg$mnT_mean_abs > 7 | agg$mnT_mean_abs < 3 | agg$BSS > 1.43, ]

g1 <- ggplot(agg, aes(x = mnT_mean_abs, y = BSS)) + 
  geom_point(color = agg$color, alpha = 0.6) +
  geom_point(data = s1, fill = s1$color, shape = 21, size = 6) +
  theme_bw() +
  coord_fixed(ratio = 2.8, xlim = c(2, 8), ylim = c(0.4, 2.7), expand = TRUE) +
  scale_x_continuous(breaks = c(2:8)) +
  scale_y_continuous(breaks = c(seq(0.5, 2.5, 0.5))) +
  labs(x = "Min Temp Error (F)", y = "Precip (1-BSS)") + 
  theme( axis.text = element_text(size = size1),
         axis.title = element_text(size = size2),
         plot.title = element_text(size = size3))

g2 <- ggplot(agg, aes(x = mxT_mean_abs, y = BSS)) + 
  geom_point(color = agg$color, alpha = 0.6) +
  geom_point(data = s2, fill = s2$color, shape = 21, size = 6) +
  theme_bw() +
  coord_fixed(ratio = 2.6, xlim = c(1.25, 7), ylim = c(0.4, 2.7), 
              expand = TRUE) +
  scale_x_continuous(breaks = c(1:7)) +
  scale_y_continuous(breaks = c(seq(0.5, 2.5, 0.5))) +
  labs(x = "Max Temp Error (F)", y = "Precip (1-BSS)") + 
  theme( axis.text = element_text(size = size1),
         axis.title = element_text(size = size2),
         plot.title = element_text(size = size3))

g3 <- ggplot(agg, aes(x = mnT_mean_abs, y = mxT_mean_abs)) + 
  geom_point(color = agg$color, alpha = 0.6) +
  geom_point(data = s3, fill = s3$color, shape = 21, size = 6) +
  theme_bw() +
  coord_fixed(ratio = 1.1, xlim = c(2, 8), ylim = c(1.25, 7), expand = TRUE) +
  scale_x_continuous(breaks = c(2:8)) +
  scale_y_continuous(breaks = c(1:7)) +
  labs(x = "Min Temp Error (F)", y = "Max Temp Error (F)") +
  theme( axis.text = element_text(size = size1),
         axis.title = element_text(size = size2),
         plot.title = element_text(size = size3))

gA <- ggplot(agg, aes(x = mnT_mean_abs, y = BSS)) + 
  geom_point(color = agg$color, alpha = 0.6) +
  geom_point(data = s4, fill = s4$color, shape = 21, size = 6) +
  theme_bw() +
  coord_fixed(ratio = 2.8, xlim = c(2, 8), ylim = c(0.4, 2.7), expand = TRUE) +
  scale_x_continuous(breaks = c(2:8)) +
  scale_y_continuous(breaks = c(seq(0.5, 2.5, 0.5))) +
  labs(x = "Min Temp Error (F)", y = "Precip (1-BSS)") +
  theme( axis.text = element_text(size = size1),
         axis.title = element_text(size = size2),
         plot.title = element_text(size = size3))


# maps
g4 <- ggplot(agg, aes(map_id = state)) +
  # map points to the fifty_states shape data
  geom_map(fill = alpha("gray80", 0.5), color = alpha("gray60", 0.5), 
           map = fifty_states) +
  expand_limits(x = fifty_states$long, y = fifty_states$lat) +
  coord_map() +
  scale_y_continuous(breaks = NULL) +
  labs(x = "", y = "") +
  geom_point(aes(x = longitude, y = latitude), color = agg$color, size = 2, 
             alpha = 0.6) +
  geom_point(data = s1, aes(x = longitude, y = latitude),
             fill = s1$color, shape = 21, size = 6) +
  scale_x_continuous(breaks = NULL) +
  theme(legend.position = "bottom",
        panel.background = element_blank(),
        axis.text = element_text(size = size1),
        axis.title = element_text(size = size2),
        plot.title = element_text(size = size3)) 

g5 <- ggplot(agg, aes(map_id = state)) +
  # map points to the fifty_states shape data
  geom_map(fill = alpha("gray80", 0.5), color = alpha("gray60", 0.5), 
           map = fifty_states) +
  expand_limits(x = fifty_states$long, y = fifty_states$lat) +
  coord_map() +
  scale_x_continuous(breaks = NULL) +
  scale_y_continuous(breaks = NULL) +
  labs(x = "", y = "") +
  geom_point(aes(x = longitude, y = latitude), color = agg$color, size = 2, 
             alpha = 0.6) +
  geom_point(data = s2, aes(x = longitude, y = latitude),
             fill = s2$color, shape = 21, size = 6) +
  theme(legend.position = "bottom",
        panel.background = element_blank(),
        axis.text = element_text(size = size1),
        axis.title = element_text(size = size2),
        plot.title = element_text(size = size3)) 

g6 <- ggplot(agg, aes(map_id = state)) +
  # map points to the fifty_states shape data
  geom_map(fill = alpha("gray80", 0.5), color = alpha("gray60", 0.5), 
           map = fifty_states) +
  expand_limits(x = fifty_states$long, y = fifty_states$lat) +
  coord_map() +
  scale_x_continuous(breaks = NULL) +
  scale_y_continuous(breaks = NULL) +
  labs(x = "", y = "") +
  geom_point(aes(x = longitude, y = latitude), color = agg$color, size = 2, 
             alpha = 0.6) +
  geom_point(data = s3, aes(x = longitude, y = latitude),
             fill = s3$color, shape = 21, size = 6) +
  theme(legend.position = "bottom",
        panel.background = element_blank(),
        axis.text = element_text(size = size1),
        axis.title = element_text(size = size2),
        plot.title = element_text(size = size3)) 

gB <- ggplot(agg, aes(map_id = state)) +
  # map points to the fifty_states shape data
  geom_map(fill = alpha("gray80", 0.5), color = alpha("gray60", 0.5), 
           map = fifty_states) +
  expand_limits(x = fifty_states$long, y = fifty_states$lat) +
  coord_map() +
  scale_x_continuous(breaks = NULL) +
  scale_y_continuous(breaks = NULL) +
  labs(x = "", y = "") +
  geom_point(aes(x = longitude, y = latitude), color = agg$color, size = 1, 
             alpha = 0.6) +
  geom_point(data = s4, aes(x = longitude, y = latitude),
             fill = s4$color, shape = 21, size = 5) +
  theme(legend.position = "bottom",
        panel.background = element_blank(),
        axis.text = element_text(size = size1),
        axis.title = element_text(size = size2),
        plot.title = element_text(size = size3)) 

#==============================================================================
# Scatterplots for forecast lags
#==============================================================================

# Select data for lags 1, 3, 5 for the graphs
lags <- scatter[is.element(scatter$lag, c(1, 3, 5)), ]

# set up parameters for plotting. I don't end up using all of these, but I left
# them in case we need them later. 
lags$alphaP1 <- ifelse(is.element(as.character(lags$AirPtCd), 
                                  as.character(s1$AirPtCd)), 1, 0.6)
lags$sizeP1 <- ifelse(is.element(as.character(lags$AirPtCd), 
                                 as.character(s1$AirPtCd)), 5, 1.5)
lags$shapeP1 <- ifelse(is.element(as.character(lags$AirPtCd), 
                                  as.character(s1$AirPtCd)), 21, 16)
lags$bordP1 <- ifelse(is.element(as.character(lags$AirPtCd), 
                                 as.character(s1$AirPtCd)), "black", 
                      lags$color)

lags$alphaP2 <- ifelse(is.element(as.character(lags$AirPtCd), 
                                  as.character(s2$AirPtCd)), 1, 0.6)
lags$sizeP2 <- ifelse(is.element(as.character(lags$AirPtCd), 
                                 as.character(s2$AirPtCd)), 5, 1.5)
lags$shapeP2 <- ifelse(is.element(as.character(lags$AirPtCd), 
                                  as.character(s2$AirPtCd)), 21, 16)
lags$bordP2 <- ifelse(is.element(as.character(lags$AirPtCd), 
                                 as.character(s2$AirPtCd)), "black", 
                      lags$color)

lags$alphaP3 <- ifelse(is.element(as.character(lags$AirPtCd), 
                                  as.character(s3$AirPtCd)), 1, 0.6)
lags$sizeP3 <- ifelse(is.element(as.character(lags$AirPtCd), 
                                 as.character(s3$AirPtCd)), 5, 1.5)
lags$shapeP3 <- ifelse(is.element(as.character(lags$AirPtCd), 
                                  as.character(s3$AirPtCd)), 21, 16)
lags$bordP3 <- ifelse(is.element(as.character(lags$AirPtCd), 
                                 as.character(s3$AirPtCd)), "black", 
                      lags$color)

lags$alphaPA <- ifelse(is.element(as.character(lags$AirPtCd), 
                                  as.character(s4$AirPtCd)), 1, 0.6)
lags$sizePA <- ifelse(is.element(as.character(lags$AirPtCd), 
                                 as.character(s4$AirPtCd)), 4, 1)
lags$shapePA <- ifelse(is.element(as.character(lags$AirPtCd), 
                                  as.character(s4$AirPtCd)), 21, 16)
lags$bordPA <- ifelse(is.element(as.character(lags$AirPtCd), 
                                 as.character(s4$AirPtCd)), "black", 
                      lags$color)

lag1 <- lags[lags$lag == 1, ]
lag3 <- lags[lags$lag == 3, ]
lag5 <- lags[lags$lag == 5, ]

# Plots showing bad min temps
lagP1.l1 <- ggplot(lag1, aes(x = mnT_mean_abs, y = BSS)) + 
  geom_point(color = lag1$color, alpha = lag1$alphaP1, size = lag1$sizeP1) +
  theme_bw() +
  coord_fixed(ratio = 2.8, xlim = c(2, 8), ylim = c(0.4, 2.7), expand = TRUE) +
  scale_x_continuous(breaks = c(2:8)) +
  scale_y_continuous(breaks = c(seq(0.5, 2.5, 0.5))) +
  labs(title = "Forecast Lag 1", x = "", y = "") + 
  theme(axis.text.y = element_blank(), 
        plot.margin = unit(c(1, 1, 1, -0.10), "cm"),
        axis.text = element_text(size = size1),
        axis.title = element_text(size = size2),
        plot.title = element_text(size = size3))

lagP1.l3 <- ggplot(lag3, aes(x = mnT_mean_abs, y = BSS)) + 
  geom_point(color = lag3$color, alpha = lag3$alphaP1, size = lag3$sizeP1) +
  theme_bw() +
  coord_fixed(ratio = 2.8, xlim = c(2, 8), ylim = c(0.4, 2.7), expand = TRUE) +
  scale_x_continuous(breaks = c(2:8)) +
  scale_y_continuous(breaks = c(seq(0.5, 2.5, 0.5))) +
  labs(title = "Forecast Lag 3", x = "Min Temp Error (F)", y = "") + 
  theme(axis.text.y = element_blank(), 
        plot.margin = unit(c(1, -0.10, 1, -0.10), "cm"),
        axis.text = element_text(size = size1),
        axis.title = element_text(size = size2),
        plot.title = element_text(size = size3))

lagP1.l5 <- ggplot(lag5, aes(x = mnT_mean_abs, y = BSS)) + 
  geom_point(color = lag5$color, alpha = lag5$alphaP1, size = lag5$sizeP1) +
  theme_bw() +
  coord_fixed(ratio = 2.8, xlim = c(2, 8), ylim = c(0.4, 2.7), expand = TRUE) +
  scale_x_continuous(breaks = c(2:8)) +
  scale_y_continuous(breaks = c(seq(0.5, 2.5, 0.5))) +
  labs(title = "Forecast Lag 5", x = "", y = "Precip (1-BSS)") +
  theme(plot.margin = unit(c(1, -0.10, 1, 1), "cm"),
        axis.text = element_text(size = size1),
        axis.title = element_text(size = size2),
        plot.title = element_text(size = size3))

# Plots showing bad precips
lagP2.l1 <- ggplot(lag1, aes(x = mxT_mean_abs, y = BSS)) + 
  geom_point(color = lag1$color, alpha = lag1$alphaP2, size = lag1$sizeP2) +
  theme_bw() +
  coord_fixed(ratio = 2.6, xlim = c(1.25, 7), ylim = c(0.4, 2.7), 
              expand = TRUE) +
  scale_x_continuous(breaks = c(1:7)) +
  scale_y_continuous(breaks = c(seq(0.5, 2.5, 0.5))) +
  labs(title = "Forecast Lag 1", x = "", y = "") + 
  theme(axis.text.y = element_blank(), 
        plot.margin = unit(c(1, 1, 1, -0.10), "cm"),
        axis.text = element_text(size = size1),
        axis.title = element_text(size = size2),
        plot.title = element_text(size = size3))

lagP2.l3 <- ggplot(lag3, aes(x = mxT_mean_abs, y = BSS)) + 
  geom_point(color = lag3$color, alpha = lag3$alphaP2, size = lag3$sizeP2) +
  theme_bw() +
  coord_fixed(ratio = 2.6, xlim = c(1.25, 7), ylim = c(0.4, 2.7), 
              expand = TRUE) +
  scale_x_continuous(breaks = c(1:7)) +
  scale_y_continuous(breaks = c(seq(0.5, 2.5, 0.5))) +
  labs(title = "Forecast Lag 3", x = "Max Temp Error (F)", y = "") + 
  theme(axis.text.y = element_blank(),
        plot.margin = unit(c(1, -0.10, 1, -0.10), "cm"),
        axis.text = element_text(size = size1),
        axis.title = element_text(size = size2),
        plot.title = element_text(size = size3))

lagP2.l5 <- ggplot(lag5, aes(x = mxT_mean_abs, y = BSS)) + 
  geom_point(color = lag5$color, alpha = lag5$alphaP2, size = lag5$sizeP2) +
  theme_bw() +
  coord_fixed(ratio = 2.6, xlim = c(1.25, 7), ylim = c(0.4, 2.7), 
              expand = TRUE) +
  scale_x_continuous(breaks = c(1:7)) +
  scale_y_continuous(breaks = c(seq(0.5, 2.5, 0.5))) +
  labs(title = "Forecast Lag 5", x = "", y = "Precip (1-BSS)") +
  theme(plot.margin = unit(c(1, -0.10, 1, 1), "cm"),
        axis.text = element_text(size = size1),
        axis.title = element_text(size = size2),
        plot.title = element_text(size = size3))


# Plots showing outliers
lagP3.l1 <- ggplot(lag1, aes(x = mnT_mean_abs, y = mxT_mean_abs)) + 
  geom_point(color = lag1$color, alpha = lag1$alphaP3, size = lag1$sizeP3) +
  theme_bw() +
  coord_fixed(ratio = 1.1, xlim = c(2, 8), ylim = c(1.25, 7), expand = TRUE) +
  scale_x_continuous(breaks = c(2:8)) +
  scale_y_continuous(breaks = c(1:7)) +
  labs(title = "Forecast Lag 1", x = "", y = "") + 
  theme(axis.text.y = element_blank(), 
        plot.margin = unit(c(1, 1, 1, -0.10), "cm"),
        axis.text = element_text(size = size1),
        axis.title = element_text(size = size2),
        plot.title = element_text(size = size3))

lagP3.l3 <- ggplot(lag3, aes(x = mnT_mean_abs, y = mxT_mean_abs)) + 
  geom_point(color = lag3$color, alpha = lag3$alphaP3, size = lag3$sizeP3) +
  theme_bw() +
  coord_fixed(ratio = 1.1, xlim = c(2, 8), ylim = c(1.25, 7), expand = TRUE) +
  scale_x_continuous(breaks = c(2:8)) +
  scale_y_continuous(breaks = c(1:7)) +
  labs(title = "Forecast Lag 3", x = "Min Temp Error (F)", y = "") + 
  theme(axis.text.y = element_blank(), 
        plot.margin = unit(c(1, -0.10, 1, -0.10), "cm"),
        axis.text = element_text(size = size1),
        axis.title = element_text(size = size2),
        plot.title = element_text(size = size3))

lagP3.l5 <- ggplot(lag5, aes(x = mnT_mean_abs, y = mxT_mean_abs)) + 
  geom_point(color = lag5$color, alpha = lag5$alphaP3, size = lag5$sizeP3) +
  theme_bw() +
  coord_fixed(ratio = 1.1, xlim = c(2, 8), ylim = c(1.25, 7), expand = TRUE) +
  scale_x_continuous(breaks = c(2:8)) +
  scale_y_continuous(breaks = c(1:7)) +
  labs(title = "Forecast Lag 5", x = "", y = "Max Temp Error (F)") +
  theme(plot.margin = unit(c(1, -0.10, 1, 1), "cm"),
        axis.text = element_text(size = size1),
        axis.title = element_text(size = size2),
        plot.title = element_text(size = size3))

# Plots for slides
lag1.sub <- lag1[is.element(as.character(lag1$AirPtCd), 
                            as.character(s4$AirPtCd)), ]
lag3.sub <- lag3[is.element(as.character(lag3$AirPtCd), 
                            as.character(s4$AirPtCd)), ]
lag5.sub <- lag5[is.element(as.character(lag5$AirPtCd), 
                            as.character(s4$AirPtCd)), ]

lagPA.l1 <- ggplot(lag1, aes(x = mnT_mean_abs, y = BSS)) + 
  geom_point(color = lag1$color, alpha = 0.6, size = 1) +
  geom_point(data = lag1.sub, fill = lag1.sub$color, alpha = 1, size = 4, 
             shape = 21) +
  theme_bw() +
  coord_fixed(ratio = 2.8, xlim = c(2, 8), ylim = c(0.4, 2.7), expand = TRUE) +
  scale_x_continuous(breaks = c(2:8)) +
  scale_y_continuous(breaks = c(seq(0.5, 2.5, 0.5))) +
  labs(title = "Forecast Lag 1", x = "", y = "") + 
  theme(axis.text.y = element_blank(), 
        plot.margin = unit(c(1, 1, 1, -0.10), "cm"),
        axis.text = element_text(size = size1),
        axis.title = element_text(size = size1),
        plot.title = element_text(size = size2))

lagPA.l3 <- ggplot(lag3, aes(x = mnT_mean_abs, y = BSS)) + 
  geom_point(color = lag3$color, alpha = 0.6, size = 1) +
  geom_point(data = lag3.sub, fill = lag3.sub$color, alpha = 1, size = 4, 
             shape = 21) +
  theme_bw() +
  coord_fixed(ratio = 2.8, xlim = c(2, 8), ylim = c(0.4, 2.7), expand = TRUE) +
  scale_x_continuous(breaks = c(2:8)) +
  scale_y_continuous(breaks = c(seq(0.5, 2.5, 0.5))) +
  labs(title = "Forecast Lag 3", x = "Min Temp Error (F)", y = "") + 
  theme(axis.text.y = element_blank(), 
        plot.margin = unit(c(1, -0.10, 1, -0.10), "cm"),
        axis.text = element_text(size = size1),
        axis.title = element_text(size = size1),
        plot.title = element_text(size = size2))

lagPA.l5 <- ggplot(lag5, aes(x = mnT_mean_abs, y = BSS)) + 
  geom_point(color = lag5$color, alpha = 0.6, size = 1) +
  geom_point(data = lag5.sub, fill = lag5.sub$color, alpha = 1, size = 4, 
             shape = 21) +
  theme_bw() +
  coord_fixed(ratio = 2.8, xlim = c(2, 8), ylim = c(0.4, 2.7), expand = TRUE) +
  scale_x_continuous(breaks = c(2:8)) +
  scale_y_continuous(breaks = c(seq(0.5, 2.5, 0.5))) +
  labs(title = "Forecast Lag 5", x = "", y = "Precip (1 - BSS)") +
  theme(plot.margin = unit(c(1, -0.10, 1, 1), "cm"),
        axis.text = element_text(size = size1),
        axis.title = element_text(size = size1),
        plot.title = element_text(size = size2))


dummy1 <- ggplot(lag5, aes(x = mnT_mean_abs, y = mxT_mean_abs)) + 
  geom_blank() +
  coord_fixed(ratio = 1.1, xlim = c(2, 8), ylim = c(1.25, 7), expand = TRUE) +
  annotate("text", x = 5, y = 4.125, label = "(a)", size = 15) + 
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.line.x = element_line(colour = "white", size = 0.5, 
                                   linetype = "solid"),
        axis.line.y = element_line(colour = "white", size = 0.5, 
                                   linetype = "solid"),
        axis.title = element_blank(),
        axis.text.y = element_blank(), 
        axis.ticks.y = element_blank(), 
        panel.grid.major = element_blank(), 
        panel.border = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_rect(fill = "white"))

dummy2 <- ggplot(lag5, aes(x = mnT_mean_abs, y = mxT_mean_abs)) + 
  geom_blank() +
  coord_fixed(ratio = 1.1, xlim = c(2, 8), ylim = c(1.25, 7), expand = TRUE) +
  annotate("text", x = 5, y = 4.125, label = "(b)", size = 15) + 
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.line.x = element_line(colour = "white", size = 0.5, 
                                   linetype = "solid"),
        axis.line.y = element_line(colour = "white", size = 0.5, 
                                   linetype = "solid"),
        axis.title = element_blank(),
        axis.text.y = element_blank(), 
        axis.ticks.y = element_blank(), 
        panel.grid.major = element_blank(), 
        panel.border = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_rect(fill = "white"))

dummy3 <- ggplot(lag5, aes(x = mnT_mean_abs, y = mxT_mean_abs)) + 
  geom_blank() +
  coord_fixed(ratio = 1.1, xlim = c(2, 8), ylim = c(1.25, 7), expand = TRUE) +
  annotate("text", x = 5, y = 4.125, label = "(c)", size = 15) + 
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.line.x = element_line(colour = "white", size = 0.5, 
                                   linetype = "solid"),
        axis.line.y = element_line(colour = "white", size = 0.5, 
                                   linetype = "solid"),
        axis.title = element_blank(),
        axis.text.y = element_blank(), 
        axis.ticks.y = element_blank(), 
        panel.grid.major = element_blank(), 
        panel.border = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_rect(fill = "white"))


png("Fig5a_ScatterTop1.png", height = 400, width = 1100)
grid.draw(cbind(ggplotGrob(lagP1.l5), ggplotGrob(lagP1.l3), 
                ggplotGrob(lagP1.l1), ggplotGrob(dummy1), size = "first"))
dev.off()

png("Fig5a_ScatterBottom1.png", height = 500, width = 1100)
grid.arrange(g1, g4, widths = c(2, 4), ncol = 2)
dev.off()

png("Fig5b_ScatterTop2.png", height = 400, width = 1100)
grid.draw(cbind(ggplotGrob(lagP2.l5), ggplotGrob(lagP2.l3), 
                ggplotGrob(lagP2.l1), ggplotGrob(dummy2), size = "first"))
dev.off()

png("Fig5b_ScatterBottom2.png", height = 500, width = 1100)
grid.arrange(g2, g5, widths = c(2, 4), ncol = 2)
dev.off()

png("Fig5c_ScatterTop3.png", height = 400, width = 1100)
grid.draw(cbind(ggplotGrob(lagP3.l5), ggplotGrob(lagP3.l3), 
                ggplotGrob(lagP3.l1), ggplotGrob(dummy3), size = "first"))
dev.off()

png("Fig5c_ScatterBottom3.png", height = 500, width = 1100)
grid.arrange(g3, g6, widths = c(2, 4), ncol = 2)
dev.off()


```

![](Fig5a_ScatterTop1.png)
![](Fig5a_ScatterBottom1.png)
![](Fig5b_ScatterTop2.png)
![](Fig5b_ScatterBottom2.png)
![](Fig5c_ScatterTop3.png)
![](Fig5c_ScatterBottom3.png)

### Figure 6: Seasonal glyph plot

This glyph plot not only provides the code for the plot in the paper, it is a good resource for creating glyphs and plotting them on a map. The coordinate system of the map distorts the glyphs, so the coordinates for the map and the glyphs need to be resolved. Original code for creating the pdf image used in the paper see the file "finalGlyphPlot.pdf". 

```{r season, echo = TRUE, comment = FALSE, message = FALSE, warning = FALSE, fig.height = 10}

# copy data for data wrangling
states <- fifty_states
weatherSum <- monthSum
loc2 <- locations

# Adjust the location of Alaska and Hawaii
longitude <- c(-117.25, -108.50)
latitude <- c(27.2, 27)
loc2$latitude[loc2$state == "Alaska"] <- latitude[1]
loc2$latitude[loc2$state == "Hawaii"] <- latitude[2]
loc2$longitude[loc2$state == "Alaska"] <- longitude[1]
loc2$longitude[loc2$state == "Hawaii"] <- longitude[2]

weatherSum$latitude[weatherSum$state == "Alaska"] <- latitude[1]
weatherSum$latitude[weatherSum$state == "Hawaii"] <- latitude[2]
weatherSum$longitude[weatherSum$state == "Alaska"] <- longitude[1]
weatherSum$longitude[weatherSum$state == "Hawaii"] <- longitude[2]

# Make a temporary data frame of coordinates so that everything gets 
# identically projected: 
coordDF <- data.frame(long = c(states$long, weatherSum$longitude, 
                               loc2$longitude),
                      lat = c(states$lat, weatherSum$latitude, 
                              loc2$latitude),
                      id = c(rep(1, nrow(states)), rep(2, nrow(weatherSum)), 
                             rep(3, nrow(loc2))))

tcoords <- mapproject(coordDF$long, coordDF$lat, projection = "mercator", 
                      parameters = NULL, orientation = NULL)

states$long <- tcoords$x[coordDF$id == 1]
states$lat <- tcoords$y[coordDF$id == 1]

weatherSum$longitude2 <- tcoords$x[coordDF$id == 2]
weatherSum$latitude2 <- tcoords$y[coordDF$id == 2]

loc2$longitude2 <- tcoords$x[coordDF$id == 3]
loc2$latitude2 <- tcoords$y[coordDF$id == 3]

weatherSum$dRad <- (pi / 2) - (((2 * pi) / 12) * (weatherSum$month - 1))

# Create a scaled version of the BSS ratio
weatherSum$sBSS <- 1 - weatherSum$BSS
weatherSum$sBSS <- weatherSum$sBSS / max(weatherSum$sBSS)

# Determine minimum and maximum Brier Skill Scores (unajusted)
minp <- min(1 - weatherSum$BSS)
maxp <- max(1 - weatherSum$BSS)

weatherSum$Cluster <- loc2$Cluster6[match(weatherSum$AirPtCd, loc2$AirPtCd)]

weatherSum.melt <- reshape2::melt(weatherSum, measure.vars = c("mxT_mean_abs", 
                                                               "mnT_mean_abs"))

# Scale the error values to the maximum of the combined set.
maxEr <- max(weatherSum.melt$value)
minEr <- min(weatherSum.melt$value)
weatherSum.melt$value2 <- weatherSum.melt$value / maxEr

weatherSum.melt$group <- paste(weatherSum.melt$AirPtCd, 
                               weatherSum.melt$variable, sep = "")

loc2$stateABB <- "none"
for (i in 1:nrow(loc2)) {loc2$stateABB[i] <- state.abb[grep(loc2$state[i], 
                                                          state.name)]}
loc2$state <- tolower(loc2$state)

# Use same color syntax for original map
pal2 <- brewer.pal(8, "Set1")[c(1:5, 8)]
pal2 <- pal2[c(4, 2, 3, 6, 1, 5)]

# Map 8 - small dots, different line thickness/intensity for each cluster. 
#=============================================================================
set1 <- c("#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", "#f781bf")
set1 <- set1[c(4, 2, 3, 6, 1, 5)] # Reorder to match the original layout
set2 <- c("#fb9a99", "#a6cee3", "#b2df8a", "#cab2d6", "#fdbf6f", "#fccde5")
set2 <- set2[c(4, 2, 3, 6, 1, 5)] # Reorder to match the original layout

weatherSum.melt$col <- "black"
weatherSum.melt$col2 <- "black"
weatherSum.melt$col[weatherSum.melt$variable == "mxT_mean_abs"] <- 
  set1[weatherSum.melt$Cluster[weatherSum.melt$variable == "mxT_mean_abs"]]
weatherSum.melt$col[weatherSum.melt$variable == "mnT_mean_abs"] <- 
  set2[weatherSum.melt$Cluster[weatherSum.melt$variable == "mnT_mean_abs"]]
weatherSum.melt$col2[weatherSum.melt$variable == "mnT_mean_abs"] <- 
  set1[weatherSum.melt$Cluster[weatherSum.melt$variable == "mnT_mean_abs"]]

weatherSum.melt$alpha <- 0.9
weatherSum.melt$alpha[weatherSum.melt$col == "#fccde5"] <- 1

# guide = FALSE idea:
# https://stackoverflow.com/questions/14604435/turning-off-some-legends-in-a-ggplot/14604540
loc2$Type <- "Temperature"

map8 <- ggplot(loc2, aes(map_id = state)) +
  # map points to the states shape data
  geom_map(
    fill = alpha("gray80", 0.5), color = alpha("gray60", 0.5), 
           map = states) +
  expand_limits(x = states$long, y = states$lat) +
  geom_point(aes(x = longitude2, y = latitude2, 
                 color = factor(Cluster6)), size = 0.1) + 
  geom_polygon(data = weatherSum.melt, 
               aes(x = longitude2 + 0.025 * value2 * cos(dRad),
                   y = latitude2 + 0.025 * value2 * sin(dRad),
                   group = factor(group)),
               color = alpha(weatherSum.melt$col, weatherSum.melt$alpha), 
               fill = NA) + 
  coord_fixed() +
  facet_grid(~Type) + 
  scale_color_manual(values =  pal2) + 
  scale_x_continuous(breaks = NULL) +
  scale_y_continuous(breaks = NULL) +
  theme(legend.position = "none",
        panel.background = element_blank(),
        axis.text = element_blank(),
        axis.title = element_blank(),
        strip.text = element_text(size = 25),
        plot.margin = unit(c(0, 0, 0, 0 ), "cm"))


# Create a custom color pallette based legend for the two colors. 
sqCol <- c(1, 2, 2, 1, 1)
sqCol <- c(sqCol, sqCol + 1, sqCol + 2, sqCol + 3, sqCol + 4, sqCol + 5)
sqRow <- rep(c(1, 1, 2, 2, 1), 6)
id = c(1, 1, 1, 1, 1)
id <- c(id, id + 1, id + 2, id + 3, id + 4, id + 5,
        id + 6, id + 7, id + 8, id + 9, id + 10, id + 11)

squareDF <- data.frame(Col = rep(sqCol, 2),
                       Row = c(sqRow, sqRow + 1),
                       id = id)

set2.temp <- set2[c(4, 3, 2, 5, 1, 6)]
set1.temp <- set1[c(4, 3, 2, 5, 1, 6)]
tleg <- ggplot(squareDF) + 
  geom_polygon(aes(x = Col, y = Row, group = id), fill = c(set2.temp, 
                                                           set1.temp)[id]) + 
  xlim(value = c(1, 13)) + 
  annotate("text", x = c(9, 9), y = c(2.5, 1.5), 
           label = c("Max Temp", "Min Temp"), size = 8) + 
  coord_fixed() +
  theme(axis.text = element_blank(),
        axis.title = element_blank(),
        axis.ticks = element_blank(),
        panel.background = element_blank(),
        plot.background = element_blank(),
        panel.grid = element_blank(),
        plot.margin = unit(c(0, 0, 0, 0), "cm"))

tleg <- ggplotGrob(tleg)

map8 <- map8 + 
  annotation_custom(tleg, xmin = 0.16, xmax = 0.56, ymin = 0.92, ymax = 1.02)
#=============================================================================


loc2$Type <- "Temperature"

map8.2 <- ggplot(loc2, aes(map_id = state)) +
  # map points to the states shape data
  geom_map(fill = alpha("gray80", 0.5), color = alpha("gray60", 0.5), 
           map = states) +
  expand_limits(x = states$long, y = states$lat) +
  geom_point(aes(x = longitude2, y = latitude2, 
                 color = factor(Cluster6)), size = 0.1) + 
  geom_polygon(data = weatherSum.melt, 
               aes(x = longitude2 + 0.025 * value2 * cos(dRad),
                   y = latitude2 + 0.025 * value2 * sin(dRad),
                   group = factor(group)),
               color = alpha(weatherSum.melt$col, weatherSum.melt$alpha), 
               fill = NA) + 
  coord_fixed() +
  facet_grid(~Type) + 
  scale_color_manual(values =  pal2) + 
  scale_x_continuous(breaks = NULL) +
  scale_y_continuous(breaks = NULL) +
  theme(legend.position = "none",
        panel.background = element_blank(),
        axis.text = element_blank(),
        axis.title = element_blank(),
        strip.text = element_text(size = 14),
        plot.margin = unit(c(0, 0, 0, 0 ), "cm"))


# Create a custom color pallette based legend for the two colors. 
sqCol <- c(1, 2, 2, 1, 1)
sqCol <- c(sqCol, sqCol + 1, sqCol + 2, sqCol + 3, sqCol + 4, sqCol + 5)
sqRow <- rep(c(1, 1, 2, 2, 1), 6)
id = c(1, 1, 1, 1, 1)
id <- c(id, id + 1, id + 2, id + 3, id + 4, id + 5,
        id + 6, id + 7, id + 8, id + 9, id + 10, id + 11)

squareDF <- data.frame(Col = rep(sqCol, 2),
                       Row = c(sqRow, sqRow + 1),
                       id = id)

set2.temp <- set2[c(4, 3, 2, 5, 1, 6)]
set1.temp <- set1[c(4, 3, 2, 5, 1, 6)]
tleg <- ggplot(squareDF) + 
  geom_polygon(aes(x = Col, y = Row, group = id), 
               fill = c(set2.temp, set1.temp)[id]) + 
  xlim(value = c(1, 13)) + 
  annotate("text", x = c(9, 9), y = c(2.5, 1.5), 
           label = c("Max Temp", "Min Temp"), size = 3) + 
  coord_fixed() +
  theme(axis.text = element_blank(),
        axis.title = element_blank(),
        axis.ticks = element_blank(),
        panel.background = element_blank(),
        plot.background = element_blank(),
        panel.grid = element_blank(),
        plot.margin = unit(c(0, 0, 0, 0), "cm"))

tleg <- ggplotGrob(tleg)

map8.2 <- map8.2 + 
  annotation_custom(tleg, xmin = 0.16, xmax = 0.56, ymin = 0.92, ymax = 1.02)
#=============================================================================


# Precip Glyph
#=============================================================================
loc2$Type <- "Precipitation"

map.2 <- ggplot(loc2, aes(map_id = state)) +
  # map points to the states shape data
  geom_map(
    fill = alpha("gray80", 0.5), color = alpha("gray60", 0.5), map = states) +
  expand_limits(x = states$long, y = states$lat) +
  geom_point(aes(x = longitude2, y = latitude2, 
                 color = factor(Cluster6)), size = 0.1) + 
  geom_polygon(data = weatherSum, 
               aes(x = longitude2 + 0.025 * sBSS * cos(dRad),
                   y = latitude2 + 0.025 * sBSS * sin(dRad),
                   group = factor(AirPtCd), color = factor(Cluster)), 
               fill = NA) + 
  facet_grid(~Type) + 
  coord_fixed() +
  scale_color_manual(values = alpha(pal2, 0.9)) + 
  scale_x_continuous(breaks = NULL) +
  scale_y_continuous(breaks = NULL) +
  theme(legend.position = "none",
        panel.background = element_blank(),
        axis.text = element_blank(),
        axis.title = element_blank(),
        strip.text = element_text(size = 14),
        plot.margin = unit(c(0, 0, 0, 0), "cm"))
#=============================================================================

# Rose Plots
marAdj <- c(0, 0, 0, 0)
#=============================================================================
# Maximum Temperature
#=============================================================================
maxSub <- weatherSum.melt[weatherSum.melt$variable == "mxT_mean_abs", ]
maxSub$Type <- "Max Temp"
minSub <- weatherSum.melt[weatherSum.melt$variable == "mnT_mean_abs", ]
minSub$Type <- "Min Temp"
tRad <- seq(0, 2 * pi, length.out = 1000)
tRad <- data.frame(tRad = tRad)

adj1 <- 2.5
adj1.1 <- 5
adj2 <- adj1 * (maxp/maxEr)
adj2.1 <- adj1.1 * (maxp/maxEr)
tglyph <- ggplot(maxSub) +
  xlim(-maxEr - adj1.1 - 7, maxEr + adj1.1 + 7) + 
  ylim(-maxEr - adj1, maxEr + adj1) + 
  geom_segment(data = maxSub, 
               aes(x = 0, xend = maxEr * cos(dRad),
                   y = 0, yend = maxEr * sin(dRad),
                   group = factor(dRad)),
               col = alpha("gray", 0.1), lwd = 0.1) + 
  annotate("text", x = (maxEr + 2) * cos(unique(maxSub$dRad)), 
           y = (maxEr + 2) * sin(unique(maxSub$dRad)),
           label = c("Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", 
                     "Sep", "Oct", "Nov", "Dec"),
           size = 7, col = "gray") + 
  geom_path(data = tRad, 
            aes(x = minEr * cos(tRad), y = minEr * sin(tRad)), 
            inherit.aes = FALSE,
            col = alpha("gray", 0.9)) + 
  geom_path(data = tRad, 
            aes(x = maxEr * cos(tRad), y = maxEr * sin(tRad)), 
            inherit.aes = FALSE,
            col = alpha("gray", 0.9)) + 
  geom_polygon(data = maxSub, 
               aes(x = value * cos(dRad),
                   y = value * sin(dRad),
                   group = factor(group)),
               inherit.aes = FALSE,
               color = alpha(maxSub$col, 0.4), 
               fill = NA) + 
  facet_grid(~Type) + 
  geom_segment(aes(y = 0, yend = maxEr, x = -maxEr - adj1.1, 
                   xend = -maxEr - adj1.1), size = 0.5) + 
  annotate("text", x = c(-maxEr - adj1.1, -maxEr - adj1.1), 
           y = c(minEr, maxEr), 
           label = as.character(round(c(minEr, maxEr), 2)),
           hjust = 1.25, size = 6) + 
  annotate("text", x = -maxEr - adj1.1, y = (minEr + maxEr) / 2, 
           label = "Abs Err", angle = 90,
           vjust = -0.5, size = 5) + 
  annotate("point", x = rep(-maxEr - adj1.1, 3) - 0.1, 
           y = c(0, minEr, maxEr) - 0.1, pch = "-", size = 6) + 
  coord_fixed() +
  theme(legend.position = "none",
        panel.background = element_blank(),
        panel.grid = element_blank(),
        axis.text = element_blank(),
        axis.title = element_blank(),
        axis.ticks = element_blank(),
        strip.text = element_text(size = 25),
        plot.margin = unit(marAdj, "cm"))
#=============================================================================

# Minimum Temperature
#=============================================================================
tglyph2 <- ggplot(minSub) +
  xlim(-maxEr - adj1.1 - 7, maxEr + adj1.1 + 7) + 
  ylim(-maxEr - adj1, maxEr + adj1) + 
  geom_segment(data = minSub, 
               aes(x = 0, xend = maxEr * cos(dRad),
                   y = 0, yend = maxEr * sin(dRad),
                   group = factor(dRad)),
               col = alpha("gray", 0.1), lwd = 0.1) + 
  annotate("text", x = (maxEr + 2) * cos(unique(minSub$dRad)), 
           y = (maxEr + 2) * sin(unique(minSub$dRad)),
           label = c("Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", 
                     "Sep", "Oct", "Nov", "Dec"),
           size = 7, col = "gray") + 
  geom_path(data = tRad, 
            aes(x = minEr * cos(tRad), y = minEr * sin(tRad)), 
            inherit.aes = FALSE,
            col = alpha("gray", 0.9)) + 
  geom_path(data = tRad, 
            aes(x = maxEr * cos(tRad), y = maxEr * sin(tRad)), 
            inherit.aes = FALSE,
            col = alpha("gray", 0.9)) + 
  geom_polygon(data = minSub, 
               aes(x = value * cos(dRad),
                   y = value * sin(dRad),
                   group = factor(group)),
               inherit.aes = FALSE,
               color = alpha(minSub$col2, 0.4), 
               fill = NA) + 
  geom_segment(aes(y = 0, yend = maxEr, x = -maxEr - adj1.1, 
                   xend = -maxEr - adj1.1), size = 0.5) + 
  annotate("text", x = c(-maxEr - adj1.1, -maxEr - adj1.1), 
           y = c(minEr, maxEr), 
           label = as.character(round(c(minEr, maxEr), 2)),
           hjust = 1.25, size = 6) + 
  annotate("text", x = -maxEr - adj1.1, y = (minEr + maxEr) / 2, 
           label = "Abs Err", angle = 90,
           vjust = -0.5, size = 5) + 
  annotate("point", x = rep(-maxEr - adj1.1, 3) - 0.1, 
           y = c(0, minEr, maxEr) - 0.1, pch = "-", size = 6) + 
  coord_fixed() +
  facet_grid(~Type) + 
  theme(legend.position = "none",
        panel.background = element_blank(),
        panel.grid = element_blank(),
        axis.text = element_blank(),
        axis.title = element_blank(),
        axis.ticks = element_blank(),
        strip.text = element_text(size = 25),
        plot.margin = unit(marAdj, "cm"))
#=============================================================================

# Precipitation
#=============================================================================
weatherSum$PrecipType <- "Precip"
tglyph3 <- ggplot(weatherSum) +
  xlim(-maxp - adj2.1 - 7 * (maxp / maxEr), 
       maxp + adj2.1 + 7 * (maxp / maxEr)) + 
  ylim(-maxp - adj2, maxp + adj2) + 
  geom_segment(data = weatherSum, 
               aes(x = 0, xend = maxp * cos(dRad),
                   y = 0, yend = maxp * sin(dRad),
                   group = factor(dRad)),
               col = alpha("gray", 0.1), lwd = 0.1) + 
  annotate("text", x = (maxp + 0.6) * cos(unique(weatherSum$dRad)), 
           y = (maxp + 0.6) * sin(unique(weatherSum$dRad)),
           label = c("Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", 
                     "Sep", "Oct", "Nov", "Dec"),
           size = 7, col = "gray") + 
  geom_path(data = tRad, 
            aes(x = minp * cos(tRad), y = minp * sin(tRad)), 
            inherit.aes = FALSE,
            col = alpha("gray", 0.9)) + 
  geom_path(data = tRad, 
            aes(x = maxp * cos(tRad), y = maxp * sin(tRad)), 
            inherit.aes = FALSE,
            col = alpha("gray", 0.9)) + 
  geom_polygon(data = weatherSum, 
               aes(x = (1 - BSS) * cos(dRad),
                   y = (1 - BSS) * sin(dRad),
                   group = factor(AirPtCd),
                   color = factor(Cluster)),
               inherit.aes = FALSE,
               fill = NA) +
  geom_segment(aes(y = 0, yend = maxp, x = -maxp - adj2.1, 
                   xend = -maxp - adj2.1), size = 0.5) + 
  annotate("text", x = c(-maxp - adj2.1, -maxp - adj2.1), y = c(minp, maxp), 
           label = as.character(round(c(minp, maxp), 2)),
           hjust = 1.5, size = 6) + 
  annotate("text", x = -maxp - adj2.1, y = (minp + maxp) / 2, 
           label = "1 - BSS", angle = 90,
           vjust = -0.5, size = 5) + 
  annotate("point", x = rep(-maxp - adj2.1, 3) - 0.1 * (maxp / maxEr), 
           y = c(0, minp, maxp) - 0.1 * (maxp/maxEr), pch = "-", size = 6) + 
  facet_grid(~PrecipType) +
  coord_fixed() +
  scale_color_manual(values =  alpha(pal2, 0.4), guide = FALSE) + 
  theme(legend.position = "none",
        panel.background = element_blank(),
        panel.grid = element_blank(),
        axis.text = element_blank(),
        axis.title = element_blank(),
        axis.ticks = element_blank(),
        strip.text = element_text(size = 26),
        plot.margin = unit(marAdj, "cm"))

#=============================================================================


# Rose Plots
marAdj <- c(0, 0, 0, 0)
#=============================================================================
# Maximum Temperature
#=============================================================================
maxSub <- weatherSum.melt[weatherSum.melt$variable == "mxT_mean_abs", ]
maxSub$Type <- "Max Temp"
minSub <- weatherSum.melt[weatherSum.melt$variable == "mnT_mean_abs", ]
minSub$Type <- "Min Temp"
tRad <- seq(0, 2 * pi, length.out = 1000)
tRad <- data.frame(tRad = tRad)

adj1 <- 2.5
adj1.1 <- 5
adj2 <- adj1 * (maxp / maxEr)
adj2.1 <- adj1.1 * (maxp / maxEr)
tglyph.2 <- ggplot(maxSub) +
  xlim(-maxEr - adj1.1 - 5, maxEr + adj1.1 + 5) + 
  ylim(-maxEr - adj1, maxEr + adj1) + 
  geom_segment(data = maxSub, 
               aes(x = 0, xend = maxEr * cos(dRad),
                   y = 0, yend = maxEr * sin(dRad),
                   group = factor(dRad)),
               col = alpha("gray", 0.1), lwd = 0.1) + 
  annotate("text", x = (maxEr + 2) * cos(unique(maxSub$dRad)), 
           y = (maxEr + 2) * sin(unique(maxSub$dRad)),
           label = c("Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", 
                     "Sep", "Oct", "Nov", "Dec"),
           size = 3, col = "gray") + 
  geom_path(data = tRad, 
            aes(x = minEr * cos(tRad), y = minEr * sin(tRad)), 
            inherit.aes = FALSE,
            col = alpha("gray", 0.9)) + 
  geom_path(data = tRad, 
            aes(x = maxEr * cos(tRad), y = maxEr * sin(tRad)), 
            inherit.aes = FALSE,
            col = alpha("gray", 0.9)) + 
  geom_polygon(data = maxSub, 
               aes(x = value * cos(dRad),
                   y = value * sin(dRad),
                   group = factor(group)),
               inherit.aes = FALSE,
               color = alpha(maxSub$col, 0.4), 
               fill = NA) + 
  facet_grid(~Type) + 
  geom_segment(aes(y = 0, yend = maxEr, x = -maxEr - adj1.1, 
                   xend = -maxEr - adj1.1), size = 0.5) + 
  annotate("text", x = c(-maxEr - adj1.1, -maxEr - adj1.1), 
           y = c(minEr, maxEr), 
           label = as.character(round(c(minEr, maxEr), 2)),
           hjust = 1.25, size = 2) + 
  annotate("text", x = -maxEr - adj1.1, y = (minEr + maxEr) / 2, 
           label = "Abs Err", angle = 90,
           vjust = -0.5, size = 2) + 
  annotate("point", x = rep(-maxEr - adj1.1, 3) - 0.1, 
           y = c(0, minEr, maxEr) - 0.1, pch = "-", size = 3) + 
  coord_fixed() +
  theme(legend.position = "none",
        panel.background = element_blank(),
        panel.grid = element_blank(),
        axis.text = element_blank(),
        axis.title = element_blank(),
        axis.ticks = element_blank(),
        strip.text = element_text(size = 14),
        plot.margin = unit(marAdj, "cm"))
#=============================================================================

# Minimum Temperature
#=============================================================================
tglyph2.2 <- ggplot(minSub) +
  xlim(-maxEr - adj1.1 - 5, maxEr + adj1.1 + 5) + 
  ylim(-maxEr - adj1, maxEr + adj1) + 
  geom_segment(data = minSub, 
               aes(x = 0, xend = maxEr * cos(dRad),
                   y = 0, yend = maxEr * sin(dRad),
                   group = factor(dRad)),
               col = alpha("gray", 0.1), lwd = 0.1) + 
  annotate("text", x = (maxEr + 2) * cos(unique(minSub$dRad)), 
           y = (maxEr + 2) * sin(unique(minSub$dRad)),
           label = c("Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", 
                     "Sep", "Oct", "Nov", "Dec"),
           size = 3, col = "gray") + 
  geom_path(data = tRad, 
            aes(x = minEr * cos(tRad), y = minEr * sin(tRad)), 
            inherit.aes = FALSE,
            col = alpha("gray", 0.9)) + 
  geom_path(data = tRad, 
            aes(x = maxEr * cos(tRad), y = maxEr * sin(tRad)), 
            inherit.aes = FALSE,
            col = alpha("gray", 0.9)) + 
  geom_polygon(data = minSub, 
               aes(x = value * cos(dRad),
                   y = value * sin(dRad),
                   group = factor(group)),
               inherit.aes = FALSE,
               color = alpha(minSub$col2, 0.4), 
               fill = NA) + 
  geom_segment(aes(y = 0, yend = maxEr, x = -maxEr - adj1.1, 
                   xend = -maxEr - adj1.1), size = 0.5) + 
  annotate("text", x = c(-maxEr - adj1.1, -maxEr - adj1.1), 
           y = c(minEr, maxEr), 
           label = as.character(round(c(minEr, maxEr), 2)),
           hjust = 1.25, size = 2) + 
  annotate("text", x = -maxEr - adj1.1, y = (minEr + maxEr) / 2, 
           label = "Abs Err", angle = 90,
           vjust = -0.5, size = 2) + 
  annotate("point", x = rep(-maxEr - adj1.1, 3) - 0.1, 
           y = c(0, minEr, maxEr) - 0.1, pch = "-", size = 3) + 
  coord_fixed() +
  facet_grid(~Type) + 
  theme(legend.position = "none",
        panel.background = element_blank(),
        panel.grid = element_blank(),
        axis.text = element_blank(),
        axis.title = element_blank(),
        axis.ticks = element_blank(),
        strip.text = element_text(size = 14),
        plot.margin = unit(marAdj, "cm"))

#=============================================================================

# Precipitation
#=============================================================================
weatherSum$PrecipType <- "Precip"
tglyph3.2 <- ggplot(weatherSum) +
  xlim(-maxp - adj2.1 - 5 * (maxp / maxEr), 
       maxp + adj2.1 + 5 * (maxp / maxEr)) + 
  ylim(-maxp - adj2, maxp + adj2) + 
  geom_segment(data = weatherSum, 
               aes(x = 0, xend = maxp * cos(dRad),
                   y = 0, yend = maxp * sin(dRad),
                   group = factor(dRad)),
               col = alpha("gray", 0.1), lwd = 0.1) + 
  annotate("text", x = (maxp + 0.6) * cos(unique(weatherSum$dRad)), 
           y = (maxp + 0.6) * sin(unique(weatherSum$dRad)),
           label = c("Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", 
                     "Sep", "Oct", "Nov", "Dec"),
           size = 3, col = "gray") + 
  geom_path(data = tRad, 
            aes(x = minp * cos(tRad), y = minp * sin(tRad)), 
            inherit.aes = FALSE,
            col = alpha("gray", 0.9)) + 
  geom_path(data = tRad, 
            aes(x = maxp * cos(tRad), y = maxp * sin(tRad)), 
            inherit.aes = FALSE,
            col = alpha("gray", 0.9)) + 
  geom_polygon(data = weatherSum, 
               aes(x = (1 - BSS) * cos(dRad),
                   y = (1 - BSS) * sin(dRad),
                   group = factor(AirPtCd),
                   color = factor(Cluster)),
               inherit.aes = FALSE,
               fill = NA) +
  geom_segment(aes(y = 0, yend = maxp, 
                   x = -maxp - adj2.1, xend = -maxp - adj2.1), size = 0.5) + 
  annotate("text", x = c(-maxp - adj2.1, -maxp - adj2.1), y = c(minp, maxp), 
           label = as.character(round(c(minp, maxp), 2)),
           hjust = 1.5, size = 2) + 
  annotate("text", x = -maxp - adj2.1, y = (minp + maxp) / 2, 
           label = "1 - BSS", angle = 90,
           vjust = -0.5, size = 2) + 
  annotate("point", x = rep(-maxp - adj2.1, 3) - 0.1 * (maxp / maxEr), 
           y = c(0, minp, maxp) - 0.1 * (maxp / maxEr), pch = "-", size = 3) + 
  facet_grid(~PrecipType) +
  coord_fixed() +
  scale_color_manual(values =  alpha(pal2, 0.4), guide = FALSE) + 
  theme(legend.position = "none",
        panel.background = element_blank(),
        panel.grid = element_blank(),
        axis.text = element_blank(),
        axis.title = element_blank(),
        axis.ticks = element_blank(),
        strip.text = element_text(size = 14),
        plot.margin = unit(marAdj, "cm"))

#=============================================================================


#=============================================================================
# First, create a set of boxes that we can color differently. 
tbox.x <- c(0, 0, 5, 5, 0)
tbox.y <- c(0, 1, 1, 0, 0)

# Now create a series of 6 boxes. 
boxes <- data.frame(x = c(tbox.x, tbox.x + 5, tbox.x + 10, tbox.x + 15, 
                          tbox.x + 20, tbox.x + 25),
                    y = rep(tbox.y, 6),
                    group = c(rep(1, 5), rep(2, 5), rep(3, 5), 
                              rep(4, 5), rep(5, 5), rep(6, 5)))

legend <- ggplot(boxes, aes(x = x, y = y)) + 
  geom_polygon(aes(fill = factor(group)), color = "white") + 
  coord_fixed() +
  scale_color_manual(values = c("#f781bf", "#4daf4a", "#377eb8",  
                                "#e41a1c", "#984ea3", "#ff7f00")) + 
  scale_fill_manual(values = c("#f781bf", "#4daf4a", "#377eb8", 
                               "#e41a1c", "#984ea3",  "#ff7f00")) + 
  annotate("text", x = 2.5 + c(0, 5, 10, 15, 20, 25), 
           y = rep(0.5, 6), 
           label = c("Cali-Florida", "Southeast", "Northeast", 
                     "Intermountain West", "Midwest", "Southwest"), 
           color = "white", size = c(3, 3, 3, 2.5, 3, 3)) + 
  theme(legend.position = "none",
        panel.background = element_blank(),
        axis.line = element_blank(),
        axis.text = element_blank(),
        axis.title = element_blank(),
        axis.ticks = element_blank())
#=============================================================================

grid.arrange(grobs = list(ggplotGrob(map8.2), ggplotGrob(tglyph.2), 
                          ggplotGrob(tglyph2.2), ggplotGrob(tglyph3.2), 
                          ggplotGrob(map.2), ggplotGrob(legend)), 
             layout_matrix = rbind(c(1,1,1), c(2, 3, 4), c(5, 5, 5), 
                                   c(6, 6, 6)),
             heights = c(0.39, 0.19, 0.39, 0.07), clip = "off")


```


### Figure 7: Variable importance plot

Random forests was used on the weather data to determine which weather variables are most important in weather forecast accuracy. The code below performs some data cleaning, the random forests computation, and the code for the plot. Original code for creating the pdf image used in the paper see the file "final_GlyphPlot_Random_Forests_VI.pdf". 

```{r vi, echo = TRUE, comment = FALSE, message = FALSE, warning = FALSE, fig.height = 6, fig.width = 10}

# rename cityForecast for datset manipulation
# clusters variable also used
rf.dat <- cityForecast

rf.dat <- left_join(rf.dat, clusters)
rf.dat <- select(rf.dat, -city, -state, -longitude, -latitude,
                 -mxT_sd, -mxT_mean, -mnT_sd, -mnT_mean,
                 -mxT_sd_abs, -mnT_sd_abs)

rf.dat$Min_Vis[rf.dat$AirPtCd == "KDMH"] <- 
  rf.dat$Min_Vis[rf.dat$AirPtCd == "KDOV"]
rf.dat$Sd_Vis[rf.dat$AirPtCd == "KDMH"] <- 
  rf.dat$Sd_Vis[rf.dat$AirPtCd == "KDOV"]
rf.dat$CloudCover[rf.dat$AirPtCd == "KDMH"] <- 
  rf.dat$CloudCover[rf.dat$AirPtCd == "KDOV"]
rf.dat$Sd_CloudCover[rf.dat$AirPtCd == "KDMH"] <- 
  rf.dat$Sd_CloudCover[rf.dat$AirPtCd == "KDOV"]

rf.dat$Min_Vis[rf.dat$AirPtCd == "KP68"] <- 
  rf.dat$Min_Vis[rf.dat$AirPtCd == "KRNO"]
rf.dat$Sd_Vis[rf.dat$AirPtCd == "KP68"] <- 
  rf.dat$Sd_Vis[rf.dat$AirPtCd == "KRNO"]
rf.dat$CloudCover[rf.dat$AirPtCd == "KP68"] <- 
  rf.dat$CloudCover[rf.dat$AirPtCd == "KRNO"]
rf.dat$Sd_CloudCover[rf.dat$AirPtCd == "KP68"] <- 
  rf.dat$Sd_CloudCover[rf.dat$AirPtCd == "KRNO"]


#==============================================================================
#                           Variable Importance
#==============================================================================

predictors <- rf.dat[, c(2:29, 33:34)]
response <- rf.dat[, c(30:32)]

set.seed(1232913)
rf6.mx <- vector("list", 6)
rf6.mn <- vector("list", 6)
rf6.precip <- vector("list", 6)
for (i in 1:6) {
  tmp.pred <- predictors[rf.dat$Cluster6 == i, ]
  tmp.res <- response[rf.dat$Cluster6 == i, ]
  rf6.mx[[i]] <- randomForest(tmp.pred, tmp.res$mxT_mean_abs, scale = FALSE, 
                             keep.forest = TRUE, importance = TRUE)
  rf6.mn[[i]] <- randomForest(tmp.pred, tmp.res$mnT_mean_abs, scale = FALSE, 
                             keep.forest = TRUE, importance = TRUE)
  rf6.precip[[i]] <- randomForest(tmp.pred, tmp.res$BSS, scale = FALSE, 
                                 keep.forest = TRUE, importance = TRUE)
}


#==============================================================================
# Parallel Coordinate Plots
#==============================================================================

clustTitle <- c("Midwest", "Northeast", "Southeast", "Cali-Florida", 
               "Intermountain West", "Southwest")
cols <- brewer.pal(8, "Set1")[c(4, 2, 3, 8, 1, 5)]

# Create a subset of variables based on the top variable selection
# for each measure and each cluster

set <- function(dat.mx, dat.mn, dat.precip, num = 5, clustNum = 6) {
  
  vars <- vector("list", clustNum)
  
  for (i in 1:clustNum) {
    tmp1 <- dat.mx[[i]]$importance[, 1][order(dat.mx[[i]]$importance[, 1], 
                                              decreasing = TRUE)]
    tmp1 <- as.data.frame((tmp1 - min(tmp1)) * 100 / max(tmp1 - min(tmp1)))
    tmp1 <- cbind(rownames(tmp1), tmp1)
    colnames(tmp1) <- c("Variable", "Importance")
    tmp1 <- tmp1[order(tmp1$Importance, decreasing = TRUE), ]
    
    tmp2 <- dat.mn[[i]]$importance[, 1][order(dat.mn[[i]]$importance[, 1], 
                                              decreasing = TRUE)]
    tmp2 <- as.data.frame((tmp2 - min(tmp2)) * 100 / max(tmp2 - min(tmp2)))
    tmp2 <- cbind(rownames(tmp2), tmp2)
    colnames(tmp2) <- c("Variable", "Importance")
    tmp2 <- tmp2[order(tmp2$Importance, decreasing = TRUE), ]
    
    tmp3 <- 
      dat.precip[[i]]$importance[, 1][order(dat.precip[[i]]$importance[, 1], 
                                                  decreasing = TRUE)]
    tmp3 <- as.data.frame((tmp3 - min(tmp3)) * 100 / max(tmp3 - min(tmp3)))
    tmp3 <- cbind(rownames(tmp3), tmp3)
    colnames(tmp3) <- c("Variable", "Importance")
    tmp3 <- tmp3[order(tmp3$Importance, decreasing = TRUE), ]
    
    vars[[i]] <- unique(c(as.character(tmp1$Variable[1:num]), 
                         as.character(tmp2$Variable[1:num]), 
                         as.character(tmp3$Variable[1:num])))
  }
  unique(c(vars[[1]], vars[[2]], vars[[3]], vars[[4]], vars[[5]], vars[[6]]))
}

set3 <- set(rf6.mx, rf6.mn, rf6.precip, num = 3)
set4 <- set(rf6.mx, rf6.mn, rf6.precip, num = 4)
set5 <- set(rf6.mx, rf6.mn, rf6.precip, num = 5)

# Clean up the labels
labels <- varNameLabels
labels <- labels[order(labels$VarName), ]
labels$order <- 1:nrow(labels)
lab1 <- labels[, 1]
lab2 <- labels[, 2]
lab2 <- factor(lab2, levels = lab2[labels$order])

# Max Temp
mxt <- as.data.frame(names(rf6.mx[[1]]$importance[, 1]))
for (i in 1:6) {
  mxt <- cbind(mxt, rf6.mx[[i]]$importance[, 1])
}

colnames(mxt) <- c("Variable", clustTitle)
mxt$CleanVar <- lab2[match(as.character(mxt$Variable), 
                           as.character(labels$VarName))]
  
for (i in 1:6) {
  mxt[, i + 1] <- mxt[, i + 1] * 100 / max(mxt[, i + 1])
}

mxt <- mxt[order(as.character(mxt$CleanVar)), ]
mxt <- gather(mxt, "Region", "Importance", 2:7)

mxt <- mxt[as.character(mxt$Variable) %in% set3, ]
mxt$Type <- "Maximum Temperature"

# Min Temp
mnt <- as.data.frame(names(rf6.mn[[1]]$importance[, 1]))
for (i in 1:6) {
  mnt <- cbind(mnt, rf6.mn[[i]]$importance[, 1])
}

colnames(mnt) <- c("Variable", clustTitle)
mnt$CleanVar <- lab2[match(as.character(mnt$Variable), 
                           as.character(labels$VarName))]

for (i in 1:6) {
  mnt[, i + 1] <- mnt[, i + 1] * 100 / max(mnt[, i + 1])
}

mnt <- mnt[order(as.character(mnt$CleanVar)), ]
mnt <- gather(mnt, "Region", "Importance", 2:7)

mnt <- mnt[as.character(mnt$Variable) %in% set3, ]
mnt$Type <- "Minimum Temperature"

# Precipitation
precip <- as.data.frame(names(rf6.precip[[1]]$importance[, 1]))
for (i in 1:6) {
  precip <- cbind(precip, rf6.precip[[i]]$importance[, 1])
}

colnames(precip) <- c("Variable", clustTitle)
precip$CleanVar <- lab2[match(as.character(precip$Variable), 
                              as.character(labels$VarName))]

for (i in 1:6) {
  precip[, i + 1] = precip[, i + 1] * 100 / max(precip[, i + 1])
}

precip <- precip[order(as.character(precip$Variable)), ]
precip <- gather(precip, "Region", "Importance", 2:7)
precip <- precip[as.character(precip$Variable) %in% set3, ]
precip$Type <- "Precipitation"

combined <- rbind(mxt, mnt, precip)


#=============================================================================
# First, create a set of boxes that we can color differently. 
tbox.x <- c(0, 0, 6, 6, 0)
tbox.y <- c(0, 8, 8, 0, 0)

# Now create a series of 6 boxes. 
boxes <- data.frame(x = c(tbox.x, tbox.x + 6, tbox.x + 12, tbox.x + 18, 
                          tbox.x + 24, tbox.x + 30),
                    y = rep(tbox.y, 6),
                    group = c(rep(1, 5), rep(2, 5), rep(3, 5), 
                              rep(4, 5), rep(5, 5), rep(6, 5)))

legend <- ggplot(boxes, aes(x = x, y = y)) + 
  geom_polygon(aes(fill = factor(group)), color = "white") + 
  coord_fixed() +
  scale_color_manual(values = c("#f781bf", "#4daf4a", "#377eb8",  
                                "#e41a1c", "#984ea3", "#ff7f00")) + 
  scale_fill_manual(values = c("#f781bf", "#4daf4a", "#377eb8", 
                               "#e41a1c", "#984ea3",  "#ff7f00")) + 
  annotate("text", x = 3 + c(0, 6, 12, 18, 24, 30), 
           y = rep(4, 6), 
           label = c("Cali-Florida", "Southeast", "Northeast", 
                     "Intermountain West", "Midwest", "Southwest"), 
           color = "white", size = c(3, 3, 3, 2.5, 3, 3)) + 
  theme(legend.position = "none",
        panel.background = element_blank(),
        axis.line = element_blank(),
        axis.text = element_blank(),
        axis.title = element_blank(),
        axis.ticks = element_blank())
#==============================================================================

gmax2 <- ggplot(combined, aes(x = CleanVar, y = Importance)) +
  geom_path(aes(group = Region, color = Region), size = 1) +
  facet_wrap(~Type, ncol = 1) +
  scale_color_manual("", values = brewer.pal(8, "Set1")[c(8, 1, 4, 2, 3, 5)]) +
  xlab("") +
  ylab("Scaled Importance") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 20, vjust  = 1, hjust = 1, 
                                   size = 12),
    legend.position = "none",
    strip.text = element_text(size = 12),
    axis.text.y = element_text(size = 12),
    axis.title.y = element_text(size = 12)) 


grid.draw(rbind(ggplotGrob(gmax2), ggplotGrob(legend), size = "first"))

```


### Figure 8: Sample ellipse

Original code for creating the pdf image used in the paper see the file "sampleEllipse.pdf". 

```{r ellipse, echo = TRUE, comment = FALSE, message = FALSE, warning = FALSE}

theta <- seq(0, 2 * pi, 0.001)
rho <- 0.5
r <- (1 - rho)^2 / (1 - sqrt(rho * (2 - rho)) * cos(theta - pi / 4))

tempdf <- data.frame(x = r * cos(theta), y = r * sin(theta))

ggplot(tempdf) +  
  # Define the axes
  geom_hline(yintercept = 0, color = "gray") +
  geom_vline(xintercept = 0, color = "gray") +
  scale_x_continuous(breaks = c(0)) + 
  scale_y_continuous(breaks = c(0)) + 
  # Define the ellipse
  geom_path(aes(x = x, y = y), lwd = 1) + 
  # Define the semi-minor axis
  geom_abline(slope = 1, intercept = 0, color = "gray", lty = 2) + 
  geom_segment(x = 0, y = 0, xend = tempdf$x[1000], yend = tempdf$y[1000]) +
  geom_curve(x = 0.5, y = 0, xend = 0.5 * cos(theta[1000]), 
             yend = 0.5 * sin(theta[1000]),
             arrow = arrow(length = unit(0.03, "npc"))) + 
  # Label points
  annotate("point", x = 0, y = 0, size = 3) +
  annotate("point", x = sqrt(rho * (2-rho) * 2), 
           y = sqrt(rho * (2 - rho) * 2), size = 3) +
  annotate("text", x = 0, y = 0, label = "F1", hjust = 1, vjust = -1, 
           size = 5) +
  annotate("text", x = sqrt(rho * (2 - rho) * 2), 
           y = sqrt(rho * (2 - rho) * 2), label = "F2", 
           hjust = 1, vjust = -1, size = 5) +
  annotate("text", x = tempdf$x[1000] / 2, y = tempdf$y[1000] / 2, label = "r",
           hjust = 1, vjust = -1, size = 5) + 
  annotate("text", x = 0.5 * cos(theta[500]), y = 0.5 * sin(theta[500]), 
           label = latex2exp::TeX("$\\theta$", output = "expression"), 
           hjust = 1, vjust = 1, size = 5) +
  theme_bw() + 
  theme(panel.grid = element_blank(),
        axis.text = element_text(size = 16),
        axis.title = element_blank()) + 
  coord_equal()



```



